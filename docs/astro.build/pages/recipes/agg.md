Astro recipes
=============

See guided examples of adding features to your Astro project.

Official Recipes
----------------

[Section titled Official Recipes](#official-recipes)

Astro’s official recipes are short, focused how-to guides that walk a reader through completing a working example of a specific task. Recipes are a great way to add new features or behavior to your Astro project by following step-by-step instructions!

*   ### [Installing a Vite or Rollup plugin](/en/recipes/add-yaml-support/)
    
    Learn how you can import YAML data by adding a Rollup plugin to your project.
    
*   ### [Analyze bundle size](/en/recipes/analyze-bundle-size/)
    
    Learn how to analyze the bundle generated by Astro using \`rollup-plugin-visualizer\`.
    
*   ### [Build a custom image component](/en/recipes/build-custom-img-component/)
    
    Learn how to build a custom image component that supports media queries using the getImage function.
    
*   ### [Build HTML forms in Astro pages](/en/recipes/build-forms/)
    
    Learn how to build HTML forms and handle submissions in your frontmatter.
    
*   ### [Build forms with API routes](/en/recipes/build-forms-api/)
    
    Learn how to use JavaScript to send form submissions to an API Route.
    
*   ### [Use Bun with Astro](/en/recipes/bun/)
    
    Learn how to use Bun with your Astro site.
    
*   ### [Call endpoints from the server](/en/recipes/call-endpoints/)
    
    Learn how to call endpoints from the server in Astro.
    
*   ### [Verify a Captcha](/en/recipes/captcha/)
    
    Learn how to create an API route and fetch it from the client.
    
*   ### [Build your Astro site with Docker](/en/recipes/docker/)
    
    Learn how to build your Astro site using Docker.
    
*   ### [Dynamically import images](/en/recipes/dynamically-importing-images/)
    
    Learn how to dynamically import images using Vite's import.meta.glob function.
    
*   ### [Add icons to external links](/en/recipes/external-links/)
    
    Learn how to install a rehype plugin to add icons to external links in your Markdown files.
    
*   ### [Add i18n features](/en/recipes/i18n/)
    
    Use dynamic routing and content collections to add internationalization support to your Astro site.
    
*   ### [Create a dev toolbar app](/en/recipes/making-toolbar-apps/)
    
    Learn how to create a dev toolbar app for your site.
    
*   ### [Add last modified time](/en/recipes/modified-time/)
    
    Build a remark plugin to add the last modified time to your Markdown and MDX.
    
*   ### [Add reading time](/en/recipes/reading-time/)
    
    Build a remark plugin to add reading time to your Markdown or MDX files.
    
*   ### [Add an RSS feed](/en/recipes/rss/)
    
    Add an RSS feed to your Astro site to let users subscribe to your content.
    
*   ### [Share state between islands](/en/recipes/sharing-state-islands/)
    
    Learn how to share state across framework components with Nano Stores.
    
*   ### [Share state between Astro components](/en/recipes/sharing-state/)
    
    Learn how to share state across Astro components with Nano Stores.
    
*   ### [Using streaming to improve page performance](/en/recipes/streaming-improve-page-performance/)
    
    Learn how to use streaming to improve page performance.
    
*   ### [Style rendered Markdown with Tailwind Typography](/en/recipes/tailwind-rendered-markdown/)
    
    Learn how to use @tailwind/typography to style your rendered Markdown.
    

Community Resources
-------------------

[Section titled Community Resources](#community-resources)

Find more recipes written and submitted by the community at [Astro Tips](https://astro-tips.dev).

Recipes

![](/_astro/CodingInPublic.DpaYu7Qd_5sx41.webp)

Learn Astro with **Coding in Public**
-------------------------------------

150+ video lessons • Astro v5 ready

[Get 20% off](https://learnastro.dev?code=ASTRO_PROMO)

document.querySelectorAll("a\[data-learn-astro-cta\]").forEach(a=>a.addEventListener("click",()=>{window.fathom?.trackEvent("Docs: Coding in Public campaign click")}));

[Edit page](https://github.com/withastro/docs/edit/main/src/content/docs/en/recipes/index.mdx) [Translate this page](https://contribute.docs.astro.build/guides/i18n/)

[Previous  
Troubleshooting](/en/guides/troubleshooting/) [Next  
Installing a Vite or Rollup plugin](/en/recipes/add-yaml-support/)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)

# Aggregated from ./pages/recipes/add-yaml-support
Installing a Vite or Rollup plugin
==================================

Astro builds on top of Vite, and supports both Vite and Rollup plugins. This recipe uses a Rollup plugin to add the ability to import a YAML (`.yml`) file in Astro.

Recipe
------

[Section titled Recipe](#recipe)

1.  Install `@rollup/plugin-yaml`:
    
    (() => { class StarlightTabsRestore extends HTMLElement { connectedCallback() { const starlightTabs = this.closest('starlight-tabs'); if (!(starlightTabs instanceof HTMLElement) || typeof localStorage === 'undefined') return; const syncKey = starlightTabs.dataset.syncKey; if (!syncKey) return; const label = localStorage.getItem(\`starlight-synced-tabs\_\_${syncKey}\`); if (!label) return; const tabs = \[...starlightTabs?.querySelectorAll('\[role="tab"\]')\]; const tabIndexToRestore = tabs.findIndex( (tab) => tab instanceof HTMLAnchorElement && tab.textContent?.trim() === label ); const panels = starlightTabs?.querySelectorAll(':scope > \[role="tabpanel"\]'); const newTab = tabs\[tabIndexToRestore\]; const newPanel = panels\[tabIndexToRestore\]; if (tabIndexToRestore < 1 || !newTab || !newPanel) return; tabs\[0\]?.setAttribute('aria-selected', 'false'); tabs\[0\]?.setAttribute('tabindex', '-1'); panels?.\[0\]?.setAttribute('hidden', 'true'); newTab.removeAttribute('tabindex'); newTab.setAttribute('aria-selected', 'true'); newPanel.removeAttribute('hidden'); } } customElements.define('starlight-tabs-restore', StarlightTabsRestore); })()
    
    *   [npm](#tab-panel-1750)
    *   [pnpm](#tab-panel-1751)
    *   [Yarn](#tab-panel-1752)
    
    Terminal window
    
        npm install @rollup/plugin-yaml --save-dev
    
    Terminal window
    
        pnpm add @rollup/plugin-yaml --save-dev
    
    Terminal window
    
        yarn add @rollup/plugin-yaml --dev
    
    class r extends HTMLElement{static#e=new Map;#t;#n="starlight-synced-tabs\_\_";constructor(){super();const t=this.querySelector('\[role="tablist"\]');if(this.tabs=\[...t.querySelectorAll('\[role="tab"\]')\],this.panels=\[...this.querySelectorAll(':scope > \[role="tabpanel"\]')\],this.#t=this.dataset.syncKey,this.#t){const i=r.#e.get(this.#t)??\[\];i.push(this),r.#e.set(this.#t,i)}this.tabs.forEach((i,c)=>{i.addEventListener("click",e=>{e.preventDefault();const n=t.querySelector('\[aria-selected="true"\]');e.currentTarget!==n&&this.switchTab(e.currentTarget,c)}),i.addEventListener("keydown",e=>{const n=this.tabs.indexOf(e.currentTarget),s=e.key==="ArrowLeft"?n-1:e.key==="ArrowRight"?n+1:e.key==="Home"?0:e.key==="End"?this.tabs.length-1:null;s!==null&&this.tabs\[s\]&&(e.preventDefault(),this.switchTab(this.tabs\[s\],s))})})}switchTab(t,i,c=!0){if(!t)return;const e=c?this.getBoundingClientRect().top:0;this.tabs.forEach(s=>{s.setAttribute("aria-selected","false"),s.setAttribute("tabindex","-1")}),this.panels.forEach(s=>{s.hidden=!0});const n=this.panels\[i\];n&&(n.hidden=!1),t.removeAttribute("tabindex"),t.setAttribute("aria-selected","true"),c&&(t.focus(),r.#r(this,t),window.scrollTo({top:window.scrollY+(this.getBoundingClientRect().top-e),behavior:"instant"}))}#i(t){!this.#t||typeof localStorage>"u"||localStorage.setItem(this.#n+this.#t,t)}static#r(t,i){const c=t.#t,e=r.#s(i);if(!c||!e)return;const n=r.#e.get(c);if(n){for(const s of n){if(s===t)continue;const a=s.tabs.findIndex(o=>r.#s(o)===e);a!==-1&&s.switchTab(s.tabs\[a\],a,!1)}t.#i(e)}}static#s(t){return t.textContent?.trim()}}customElements.define("starlight-tabs",r);
2.  Import the plugin in your `astro.config.mjs` and add it to the Vite plugins array:
    
    astro.config.mjs
    
        import { defineConfig } from 'astro/config';import yaml from '@rollup/plugin-yaml';
        export default defineConfig({  vite: {    plugins: [yaml()]  }});
    
3.  Finally, you can import YAML data using an `import` statement:
    
        import yml from './data.yml';
    
    Note
    
    While you can now import YAML data in your Astro project, your editor will not provide types for the imported data. To add types, create or find an existing `*.d.ts` file in the `src` directory of your project and add the following:
    
    src/files.d.ts
    
        // Specify the file extension you want to importdeclare module "*.yml" {  const value: any; // Add type definitions here if desired  export default value;}
    
    This will allow your editor to provide type hints for your YAML data.
    

Recipes

![](/_astro/CodingInPublic.DpaYu7Qd_5sx41.webp)

Learn Astro with **Coding in Public**
-------------------------------------

150+ video lessons • Astro v5 ready

[Get 20% off](https://learnastro.dev?code=ASTRO_PROMO)

document.querySelectorAll("a\[data-learn-astro-cta\]").forEach(a=>a.addEventListener("click",()=>{window.fathom?.trackEvent("Docs: Coding in Public campaign click")}));

[Edit page](https://github.com/withastro/docs/edit/main/src/content/docs/en/recipes/add-yaml-support.mdx) [Translate this page](https://contribute.docs.astro.build/guides/i18n/)

[Previous  
Recipes overview](/en/recipes/) [Next  
Analyze bundle size](/en/recipes/analyze-bundle-size/)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)



# Aggregated from ./pages/recipes/analyze-bundle-size
Analyze bundle size
===================

Understanding what is a part of an Astro bundle is important for improving site performance. Visualizing the bundle can give clues as to where changes can be made in your project to reduce the bundle size.

Recipe
------

[Section titled Recipe](#recipe)

The [`rollup-plugin-visualizer` library](https://github.com/btd/rollup-plugin-visualizer) allows you to visualize and analyze your Rollup bundle to see which modules are taking up space.

1.  Install `rollup-plugin-visualizer`:
    
    (() => { class StarlightTabsRestore extends HTMLElement { connectedCallback() { const starlightTabs = this.closest('starlight-tabs'); if (!(starlightTabs instanceof HTMLElement) || typeof localStorage === 'undefined') return; const syncKey = starlightTabs.dataset.syncKey; if (!syncKey) return; const label = localStorage.getItem(\`starlight-synced-tabs\_\_${syncKey}\`); if (!label) return; const tabs = \[...starlightTabs?.querySelectorAll('\[role="tab"\]')\]; const tabIndexToRestore = tabs.findIndex( (tab) => tab instanceof HTMLAnchorElement && tab.textContent?.trim() === label ); const panels = starlightTabs?.querySelectorAll(':scope > \[role="tabpanel"\]'); const newTab = tabs\[tabIndexToRestore\]; const newPanel = panels\[tabIndexToRestore\]; if (tabIndexToRestore < 1 || !newTab || !newPanel) return; tabs\[0\]?.setAttribute('aria-selected', 'false'); tabs\[0\]?.setAttribute('tabindex', '-1'); panels?.\[0\]?.setAttribute('hidden', 'true'); newTab.removeAttribute('tabindex'); newTab.setAttribute('aria-selected', 'true'); newPanel.removeAttribute('hidden'); } } customElements.define('starlight-tabs-restore', StarlightTabsRestore); })()
    
    *   [npm](#tab-panel-1753)
    *   [pnpm](#tab-panel-1754)
    *   [Yarn](#tab-panel-1755)
    
    Terminal window
    
        npm install rollup-plugin-visualizer --save-dev
    
    Terminal window
    
        pnpm add rollup-plugin-visualizer --save-dev
    
    Terminal window
    
        yarn add rollup-plugin-visualizer --save-dev
    
    class r extends HTMLElement{static#e=new Map;#t;#n="starlight-synced-tabs\_\_";constructor(){super();const t=this.querySelector('\[role="tablist"\]');if(this.tabs=\[...t.querySelectorAll('\[role="tab"\]')\],this.panels=\[...this.querySelectorAll(':scope > \[role="tabpanel"\]')\],this.#t=this.dataset.syncKey,this.#t){const i=r.#e.get(this.#t)??\[\];i.push(this),r.#e.set(this.#t,i)}this.tabs.forEach((i,c)=>{i.addEventListener("click",e=>{e.preventDefault();const n=t.querySelector('\[aria-selected="true"\]');e.currentTarget!==n&&this.switchTab(e.currentTarget,c)}),i.addEventListener("keydown",e=>{const n=this.tabs.indexOf(e.currentTarget),s=e.key==="ArrowLeft"?n-1:e.key==="ArrowRight"?n+1:e.key==="Home"?0:e.key==="End"?this.tabs.length-1:null;s!==null&&this.tabs\[s\]&&(e.preventDefault(),this.switchTab(this.tabs\[s\],s))})})}switchTab(t,i,c=!0){if(!t)return;const e=c?this.getBoundingClientRect().top:0;this.tabs.forEach(s=>{s.setAttribute("aria-selected","false"),s.setAttribute("tabindex","-1")}),this.panels.forEach(s=>{s.hidden=!0});const n=this.panels\[i\];n&&(n.hidden=!1),t.removeAttribute("tabindex"),t.setAttribute("aria-selected","true"),c&&(t.focus(),r.#r(this,t),window.scrollTo({top:window.scrollY+(this.getBoundingClientRect().top-e),behavior:"instant"}))}#i(t){!this.#t||typeof localStorage>"u"||localStorage.setItem(this.#n+this.#t,t)}static#r(t,i){const c=t.#t,e=r.#s(i);if(!c||!e)return;const n=r.#e.get(c);if(n){for(const s of n){if(s===t)continue;const a=s.tabs.findIndex(o=>r.#s(o)===e);a!==-1&&s.switchTab(s.tabs\[a\],a,!1)}t.#i(e)}}static#s(t){return t.textContent?.trim()}}customElements.define("starlight-tabs",r);
2.  Add the plugin to the `astro.config.mjs` file:
    
        // @ts-checkimport { defineConfig } from 'astro/config';import { visualizer } from "rollup-plugin-visualizer";
        export default defineConfig({vite: {    plugins: [visualizer({        emitFile: true,        filename: "stats.html",    })]}});
    
3.  Run the build command:
    
    *   [npm](#tab-panel-1756)
    *   [pnpm](#tab-panel-1757)
    *   [Yarn](#tab-panel-1758)
    
    Terminal window
    
        npm run build
    
    Terminal window
    
        pnpm build
    
    Terminal window
    
        yarn build
    
4.  Find the `stats.html` file(s) for your project.
    
    This will be at the root of your `dist/` directory for entirely static sites and will allow you to see what is included in the bundle.
    
    If your Astro project uses on-demand rendering, you will have two `stats.html` files. One will be for the client, and the other for the server, and each will be located at the root of the `dist/client` and `dist/server/` directories.
    
    See [the Rollup Plugin Visualizer documentation](https://github.com/btd/rollup-plugin-visualizer#how-to-use-generated-files) for guidance on how to interpret these files, or configure specific options.
    

Note

Given Astro’s unique approach to hydration, the build isn’t necessarily representative of the bundle that the client will receive.

The Rollup visualizer shows all dependencies that are used across the site, but it does not break down the bundle size on a per-page basis.

Recipes

![](/_astro/CodingInPublic.DpaYu7Qd_5sx41.webp)

Learn Astro with **Coding in Public**
-------------------------------------

150+ video lessons • Astro v5 ready

[Get 20% off](https://learnastro.dev?code=ASTRO_PROMO)

document.querySelectorAll("a\[data-learn-astro-cta\]").forEach(a=>a.addEventListener("click",()=>{window.fathom?.trackEvent("Docs: Coding in Public campaign click")}));

[Edit page](https://github.com/withastro/docs/edit/main/src/content/docs/en/recipes/analyze-bundle-size.mdx) [Translate this page](https://contribute.docs.astro.build/guides/i18n/)

[Previous  
Installing a Vite or Rollup plugin](/en/recipes/add-yaml-support/) [Next  
Build a custom image component](/en/recipes/build-custom-img-component/)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)



# Aggregated from ./pages/recipes/build-custom-img-component
Build a custom image component
==============================

Astro provides two built-in components that you can use to display and optimize your images. The `<Picture>` component allows you to display responsive images and work with different formats and sizes. The `<Image>` component will optimize your images and allow you to pass in different formats and quality properties.

When you need options that the `<Picture>` and `<Image>` components do not currently support, you can use the `getImage()` function to create a custom component.

In this recipe, you will use the [`getImage()` function](/en/guides/images/#generating-images-with-getimage) to create your own custom image component that displays different source images based on media queries.

Recipe
------

[Section titled Recipe](#recipe)

1.  Create a new Astro component and import the `getImage()` function
    
    src/components/MyCustomImageComponent.astro
    
        --- import { getImage } from "astro:assets";---
    
2.  Create a new component for your custom image. `MyCustomComponent.astro` will receive three `props` from `Astro.props`. The `mobileImgUrl` and `desktopImgUrl` props are used for creating your image at different viewport sizes. The `alt` prop is used for the image’s alt text. These props will be passed wherever you render your custom image components. Add the following imports and define the props that you will use in your component. You can also use TypeScript to type the props.
    
    src/components/MyCustomImageComponent.astro
    
        ---import type { ImageMetadata } from "astro";import { getImage } from "astro:assets";
        interface Props {    mobileImgUrl: string | ImageMetadata;    desktopImgUrl: string | ImageMetadata;    alt: string;}
        const { mobileImgUrl, desktopImgUrl, alt } = Astro.props;---
    
3.  Define each of your responsive images by calling the `getImage()` function with your desired properties.
    
    src/components/MyCustomImageComponent.astro
    
        ---import type { ImageMetadata } from "astro";import { getImage } from "astro:assets";
        interface Props {    mobileImgUrl: string | ImageMetadata;    desktopImgUrl: string | ImageMetadata;    alt: string;}
        const { mobileImgUrl, desktopImgUrl, alt } = Astro.props;
        const mobileImg = await getImage({    src: mobileImgUrl,    format: "webp",    width: 200,    height: 200,});
        const desktopImg = await getImage({    src: desktopImgUrl,    format: "webp",    width: 800,    height: 200,});---
    
4.  Create a `<picture>` element that generates a `srcset` with your different images based on your desired media queries.
    
    src/components/MyCustomImageComponent.astro
    
        ---import type { ImageMetadata } from "astro";import { getImage } from "astro:assets";
        interface Props {    mobileImgUrl: string | ImageMetadata;    desktopImgUrl: string | ImageMetadata;    alt: string;}
        const { mobileImgUrl, desktopImgUrl, alt } = Astro.props;
        const mobileImg = await getImage({    src: mobileImgUrl,    format: "webp",    width: 200,    height: 200,});
        const desktopImg = await getImage({    src: desktopImgUrl,    format: "webp",    width: 800,    height: 200,});---
        <picture>    <source media="(max-width: 799px)" srcset={mobileImg.src} />    <source media="(min-width: 800px)" srcset={desktopImg.src} />    <img src={desktopImg.src} alt={alt} /></picture>
    
5.  Import and use `<MyCustomImageComponent />` in any `.astro` file. Be sure to pass the necessary props for generating two different images at the different viewport sizes:
    
    src/pages/index.astro
    
        ---import MyCustomImageComponent from "../components/MyCustomImageComponent.astro";import mobileImage from "../images/mobile-profile-image.jpg";import desktopImage from "../images/desktop-profile-image.jpg";---
        <MyCustomImageComponent    mobileImgUrl={mobileImage}    desktopImgUrl={desktopImage}    alt="user profile picture"/>
    

Recipes

![](/_astro/CodingInPublic.DpaYu7Qd_5sx41.webp)

Learn Astro with **Coding in Public**
-------------------------------------

150+ video lessons • Astro v5 ready

[Get 20% off](https://learnastro.dev?code=ASTRO_PROMO)

document.querySelectorAll("a\[data-learn-astro-cta\]").forEach(a=>a.addEventListener("click",()=>{window.fathom?.trackEvent("Docs: Coding in Public campaign click")}));

[Edit page](https://github.com/withastro/docs/edit/main/src/content/docs/en/recipes/build-custom-img-component.mdx) [Translate this page](https://contribute.docs.astro.build/guides/i18n/)

[Previous  
Analyze bundle size](/en/recipes/analyze-bundle-size/) [Next  
Build HTML forms in Astro pages](/en/recipes/build-forms/)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)



# Aggregated from ./pages/recipes/build-forms-api
Build forms with API routes
===========================

An HTML form causes the browser to refresh the page or navigate to a new one. To send form data to an API endpoint instead, you must intercept the form submission using JavaScript.

This recipe shows you how to send form data to an API endpoint and handle that data.

Prerequisites
-------------

[Section titled Prerequisites](#prerequisites)

*   A project with [an adapter for on-demand rendering](/en/guides/on-demand-rendering/)
*   A [UI Framework integration](/en/guides/framework-components/) installed

Recipe
------

[Section titled Recipe](#recipe)

1.  Create a `POST` API endpoint at `/api/feedback` that will receive the form data. Use `request.formData()` to process it. Be sure to validate the form values before you use them.
    
    This example sends a JSON object with a message back to the client.
    
    src/pages/api/feedback.ts
    
        export const prerender = false; // Not needed in 'server' modeimport type { APIRoute } from "astro";
        export const POST: APIRoute = async ({ request }) => {  const data = await request.formData();  const name = data.get("name");  const email = data.get("email");  const message = data.get("message");  // Validate the data - you'll probably want to do more than this  if (!name || !email || !message) {    return new Response(      JSON.stringify({        message: "Missing required fields",      }),      { status: 400 }    );  }  // Do something with the data, then return a success response  return new Response(    JSON.stringify({      message: "Success!"    }),    { status: 200 }  );};
    
2.  Create a form component using your UI framework. Each input should have a `name` attribute that describes the value of that input.
    
    Be sure to include a `<button>` or `<input type="submit">` element to submit the form.
    
    (() => { class StarlightTabsRestore extends HTMLElement { connectedCallback() { const starlightTabs = this.closest('starlight-tabs'); if (!(starlightTabs instanceof HTMLElement) || typeof localStorage === 'undefined') return; const syncKey = starlightTabs.dataset.syncKey; if (!syncKey) return; const label = localStorage.getItem(\`starlight-synced-tabs\_\_${syncKey}\`); if (!label) return; const tabs = \[...starlightTabs?.querySelectorAll('\[role="tab"\]')\]; const tabIndexToRestore = tabs.findIndex( (tab) => tab instanceof HTMLAnchorElement && tab.textContent?.trim() === label ); const panels = starlightTabs?.querySelectorAll(':scope > \[role="tabpanel"\]'); const newTab = tabs\[tabIndexToRestore\]; const newPanel = panels\[tabIndexToRestore\]; if (tabIndexToRestore < 1 || !newTab || !newPanel) return; tabs\[0\]?.setAttribute('aria-selected', 'false'); tabs\[0\]?.setAttribute('tabindex', '-1'); panels?.\[0\]?.setAttribute('hidden', 'true'); newTab.removeAttribute('tabindex'); newTab.setAttribute('aria-selected', 'true'); newPanel.removeAttribute('hidden'); } } customElements.define('starlight-tabs-restore', StarlightTabsRestore); })()
    
    *   [Preact](#tab-panel-1759)
    *   [React](#tab-panel-1760)
    *   [Solid](#tab-panel-1761)
    *   [Svelte](#tab-panel-1762)
    *   [Vue](#tab-panel-1763)
    
    src/components/FeedbackForm.tsx
    
        export default function Form() {  return (    <form>      <label>        Name        <input type="text" id="name" name="name" required />      </label>      <label>        Email        <input type="email" id="email" name="email" required />      </label>      <label>        Message        <textarea id="message" name="message" required />      </label>      <button>Send</button>    </form>  );}
    
    src/components/FeedbackForm.tsx
    
        export default function Form() {  return (    <form>      <label>        Name        <input type="text" id="name" name="name" required />      </label>      <label>        Email        <input type="email" id="email" name="email" required />      </label>      <label>        Message        <textarea id="message" name="message" required />      </label>      <button>Send</button>    </form>  );}
    
    src/components/FeedbackForm.tsx
    
        export default function Form() {  return (    <form>      <label>        Name        <input type="text" id="name" name="name" required />      </label>      <label>        Email        <input type="email" id="email" name="email" required />      </label>      <label>        Message        <textarea id="message" name="message" required />      </label>      <button>Send</button>    </form>  );}
    
    src/components/FeedbackForm.svelte
    
        <form>  <label>    Name    <input type="text" id="name" name="name" required />  </label>  <label>    Email    <input type="email" id="email" name="email" required />  </label>  <label>    Message    <textarea id="message" name="message" required />  </label>  <button>Send</button></form>
    
    src/components/FeedbackForm.vue
    
        <template>  <form>    <label>      Name      <input type="text" id="name" name="name" required />    </label>    <label>      Email      <input type="email" id="email" name="email" required />    </label>    <label>      Message      <textarea id="message" name="message" required />    </label>    <button>Send</button>  </form></template>
    
    class r extends HTMLElement{static#e=new Map;#t;#n="starlight-synced-tabs\_\_";constructor(){super();const t=this.querySelector('\[role="tablist"\]');if(this.tabs=\[...t.querySelectorAll('\[role="tab"\]')\],this.panels=\[...this.querySelectorAll(':scope > \[role="tabpanel"\]')\],this.#t=this.dataset.syncKey,this.#t){const i=r.#e.get(this.#t)??\[\];i.push(this),r.#e.set(this.#t,i)}this.tabs.forEach((i,c)=>{i.addEventListener("click",e=>{e.preventDefault();const n=t.querySelector('\[aria-selected="true"\]');e.currentTarget!==n&&this.switchTab(e.currentTarget,c)}),i.addEventListener("keydown",e=>{const n=this.tabs.indexOf(e.currentTarget),s=e.key==="ArrowLeft"?n-1:e.key==="ArrowRight"?n+1:e.key==="Home"?0:e.key==="End"?this.tabs.length-1:null;s!==null&&this.tabs\[s\]&&(e.preventDefault(),this.switchTab(this.tabs\[s\],s))})})}switchTab(t,i,c=!0){if(!t)return;const e=c?this.getBoundingClientRect().top:0;this.tabs.forEach(s=>{s.setAttribute("aria-selected","false"),s.setAttribute("tabindex","-1")}),this.panels.forEach(s=>{s.hidden=!0});const n=this.panels\[i\];n&&(n.hidden=!1),t.removeAttribute("tabindex"),t.setAttribute("aria-selected","true"),c&&(t.focus(),r.#r(this,t),window.scrollTo({top:window.scrollY+(this.getBoundingClientRect().top-e),behavior:"instant"}))}#i(t){!this.#t||typeof localStorage>"u"||localStorage.setItem(this.#n+this.#t,t)}static#r(t,i){const c=t.#t,e=r.#s(i);if(!c||!e)return;const n=r.#e.get(c);if(n){for(const s of n){if(s===t)continue;const a=s.tabs.findIndex(o=>r.#s(o)===e);a!==-1&&s.switchTab(s.tabs\[a\],a,!1)}t.#i(e)}}static#s(t){return t.textContent?.trim()}}customElements.define("starlight-tabs",r);
3.  Create a function that accepts a submit event, then pass it as a `submit` handler to your form.
    
    In the function:
    
    *   Call `preventDefault()` on the event to override the browser’s default submission process.
    *   Create a `FormData` object and send it in a `POST` request to your endpoint using `fetch()`.
    
    *   [Preact](#tab-panel-1764)
    *   [React](#tab-panel-1765)
    *   [Solid](#tab-panel-1766)
    *   [Svelte](#tab-panel-1767)
    *   [Vue](#tab-panel-1768)
    
    src/components/FeedbackForm.tsx
    
        import { useState } from "preact/hooks";
        export default function Form() {  const [responseMessage, setResponseMessage] = useState("");
          async function submit(e: SubmitEvent) {    e.preventDefault();    const formData = new FormData(e.target as HTMLFormElement);    const response = await fetch("/api/feedback", {      method: "POST",      body: formData,    });    const data = await response.json();    if (data.message) {      setResponseMessage(data.message);    }  }
          return (    <form onSubmit={submit}>      <label>        Name        <input type="text" id="name" name="name" required />      </label>      <label>        Email        <input type="email" id="email" name="email" required />      </label>      <label>        Message        <textarea id="message" name="message" required />      </label>      <button>Send</button>      {responseMessage && <p>{responseMessage}</p>}    </form>  );}
    
    src/components/FeedbackForm.tsx
    
        import { useState } from "react";import type { FormEvent } from "react";
        export default function Form() {  const [responseMessage, setResponseMessage] = useState("");
          async function submit(e: FormEvent<HTMLFormElement>) {    e.preventDefault();    const formData = new FormData(e.target as HTMLFormElement);    const response = await fetch("/api/feedback", {      method: "POST",      body: formData,    });    const data = await response.json();    if (data.message) {      setResponseMessage(data.message);    }  }
          return (    <form onSubmit={submit}>      <label htmlFor="name">        Name        <input type="text" id="name" name="name" autoComplete="name" required />      </label>      <label htmlFor="email">        Email        <input type="email" id="email" name="email" autoComplete="email" required />      </label>      <label htmlFor="message">        Message        <textarea id="message" name="message" autoComplete="off" required />      </label>      <button>Send</button>      {responseMessage && <p>{responseMessage}</p>}    </form>  );}
    
    src/components/FeedbackForm.tsx
    
        import { createSignal, createResource, Suspense } from "solid-js";
        async function postFormData(formData: FormData) {  const response = await fetch("/api/feedback", {    method: "POST",    body: formData,  });  const data = await response.json();  return data;}
        export default function Form() {  const [formData, setFormData] = createSignal<FormData>();  const [response] = createResource(formData, postFormData);
          function submit(e: SubmitEvent) {    e.preventDefault();    setFormData(new FormData(e.target as HTMLFormElement));  }
          return (    <form onSubmit={submit}>      <label>        Name        <input type="text" id="name" name="name" required />      </label>      <label>        Email        <input type="email" id="email" name="email" required />      </label>      <label>        Message        <textarea id="message" name="message" required />      </label>      <button>Send</button>      <Suspense>{response() && <p>{response().message}</p>}</Suspense>    </form>  );}
    
    src/components/FeedbackForm.svelte
    
        <script lang="ts">  let responseMessage: string;
          async function submit(e: SubmitEvent) {    e.preventDefault();    const formData = new FormData(e.currentTarget as HTMLFormElement);    const response = await fetch("/api/feedback", {      method: "POST",      body: formData,    });    const data = await response.json();    responseMessage = data.message;  }</script>
        <form on:submit={submit}>  <label>    Name    <input type="text" id="name" name="name" required />  </label>  <label>    Email    <input type="email" id="email" name="email" required />  </label>  <label>    Message    <textarea id="message" name="message" required />  </label>  <button>Send</button>  {#if responseMessage}    <p>{responseMessage}</p>  {/if}</form>
    
    src/components/FeedbackForm.vue
    
        <script setup lang="ts">import { ref } from "vue";
        const responseMessage = ref<string>();
        async function submit(e: Event) {  e.preventDefault();  const formData = new FormData(e.currentTarget as HTMLFormElement);  const response = await fetch("/api/feedback", {    method: "POST",    body: formData,  });  const data = await response.json();  responseMessage.value = data.message;}</script>
        <template>  <form @submit="submit">    <label>      Name      <input type="text" id="name" name="name" required />    </label>    <label>      Email      <input type="email" id="email" name="email" required />    </label>    <label>      Message      <textarea id="message" name="message" required />    </label>    <button>Send</button>    <p v-if="responseMessage">{{ responseMessage }}</p>  </form></template>
    
4.  Import and include your `<FeedbackForm />` component on a page. Be sure to use a `client:*` directive to ensure that the form logic is hydrated when you want it to be.
    
    *   [Preact](#tab-panel-1769)
    *   [React](#tab-panel-1770)
    *   [Solid](#tab-panel-1771)
    *   [Svelte](#tab-panel-1772)
    *   [Vue](#tab-panel-1773)
    
    src/pages/index.astro
    
        ---import FeedbackForm from "../components/FeedbackForm"---<FeedbackForm client:load />
    
    src/pages/index.astro
    
        ---import FeedbackForm from "../components/FeedbackForm"---<FeedbackForm client:load />
    
    src/pages/index.astro
    
        ---import FeedbackForm from "../components/FeedbackForm"---<FeedbackForm client:load />
    
    src/pages/index.astro
    
        ---import FeedbackForm from "../components/FeedbackForm.svelte"---<FeedbackForm client:load />
    
    src/pages/index.astro
    
        ---import FeedbackForm from "../components/FeedbackForm.vue"---<FeedbackForm client:load />
    

Recipes

![](/_astro/CodingInPublic.DpaYu7Qd_5sx41.webp)

Learn Astro with **Coding in Public**
-------------------------------------

150+ video lessons • Astro v5 ready

[Get 20% off](https://learnastro.dev?code=ASTRO_PROMO)

document.querySelectorAll("a\[data-learn-astro-cta\]").forEach(a=>a.addEventListener("click",()=>{window.fathom?.trackEvent("Docs: Coding in Public campaign click")}));

[Edit page](https://github.com/withastro/docs/edit/main/src/content/docs/en/recipes/build-forms-api.mdx) [Translate this page](https://contribute.docs.astro.build/guides/i18n/)

[Previous  
Build HTML forms in Astro pages](/en/recipes/build-forms/) [Next  
Use Bun with Astro](/en/recipes/bun/)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)



# Aggregated from ./pages/recipes/build-forms
Build HTML forms in Astro pages
===============================

Astro pages that are rendered on demand can both display and handle forms. In this recipe, you’ll use a standard HTML form to submit data to the server. Your frontmatter script will handle the data on the server, sending no JavaScript to the client.

Prerequisites
-------------

[Section titled Prerequisites](#prerequisites)

*   An Astro project with a [server adapter](/en/guides/on-demand-rendering/#server-adapters) installed.

Recipe
------

[Section titled Recipe](#recipe)

1.  Create or identify a `.astro` page which will contain your form and your handling code. For example, you could add a registration page:
    
    src/pages/register.astro
    
        ------<h1>Register</h1>
    
2.  Add a `<form>` tag with some inputs to the page. Each input should have a `name` attribute that describes the value of that input.
    
    Be sure to include a `<button>` or `<input type="submit">` element to submit the form.
    
    src/pages/register.astro
    
        ------<h1>Register</h1><form>  <label>    Username:    <input type="text" name="username" />  </label>  <label>    Email:    <input type="email" name="email" />  </label>  <label>    Password:    <input type="password" name="password" />  </label>  <button>Submit</button></form>
    
3.  Use [validation attributes](https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation#using_built-in_form_validation) to provide basic client-side validation that works even if JavaScript is disabled.
    
    In this example,
    
    *   `required` prevents form submission until the field is filled.
    *   `minlength` sets a minimum required length for the input text.
    *   `type="email"` also introduces validation that will only accept a valid email format.
    
    src/pages/register.astro
    
        ------<h1>Register</h1><form>  <label>    Username:    <input type="text" name="username" required />  </label>  <label>    Email:    <input type="email" name="email" required />  </label>  <label>    Password:    <input type="password" name="password" required minlength="6" />  </label>  <button>Submit</button></form>
    
    Tip
    
    You can add custom validation logic that refers to multiple fields using a `<script>` tag and the [Constraint Validation API](https://developer.mozilla.org/en-US/docs/Web/HTML/Constraint_validation#complex_constraints_using_the_constraint_validation_api).
    
    To write complex validation logic more easily, you can build your form using a [frontend framework](/en/guides/framework-components/) and choose a form library like [React Hook Form](https://react-hook-form.com/) or [Felte](https://felte.dev/).
    
4.  The form submission will cause the browser to request the page again. Change the form’s data transfer `method` to `POST` to send the form data as part of the `Request` body, rather than as URL parameters.
    
    src/pages/register.astro
    
        ------<h1>Register</h1><form method="POST">  <label>    Username:    <input type="text" name="username" required />  </label>  <label>    Email:    <input type="email" name="email" required />  </label>  <label>    Password:    <input type="password" name="password" required minlength="6" />  </label>  <button>Submit</button></form>
    
5.  Check for the `POST` method in the frontmatter and access the form data using `Astro.request.formData()`. Wrap this in a `try ... catch` block to handle cases when the `POST` request wasn’t sent by a form and the `formData` is invalid.
    
    src/pages/register.astro
    
        ---if (Astro.request.method === "POST") {  try {    const data = await Astro.request.formData();    const name = data.get("username");    const email = data.get("email");    const password = data.get("password");    // Do something with the data  } catch (error) {    if (error instanceof Error) {      console.error(error.message);    }  }}---<h1>Register</h1><form method="POST">  <label>    Username:    <input type="text" name="username" required />  </label>  <label>    Email:    <input type="email" name="email" required />  </label>  <label>    Password:    <input type="password" name="password" required minlength="6" />  </label>  <button>Submit</button></form>
    
6.  Validate the form data on the server. This should include the same validation done on the client to prevent malicious submissions to your endpoint and to support the rare legacy browser that doesn’t have form validation.
    
    It can also include validation that can’t be done on the client. For example, this example checks if the email is already in the database.
    
    Error messages can be sent back to the client by storing them in an `errors` object and accessing it in the template.
    
    src/pages/register.astro
    
        ---import { isRegistered, registerUser } from "../../data/users"import { isValidEmail } from "../../utils/isValidEmail";
        const errors = { username: "", email: "", password: "" };if (Astro.request.method === "POST") {  try {    const data = await Astro.request.formData();    const name = data.get("username");    const email = data.get("email");    const password = data.get("password");    if (typeof name !== "string" || name.length < 1) {      errors.username += "Please enter a username. ";    }    if (typeof email !== "string" || !isValidEmail(email)) {      errors.email += "Email is not valid. ";    } else if (await isRegistered(email)) {      errors.email += "Email is already registered. ";    }    if (typeof password !== "string" || password.length < 6) {      errors.password += "Password must be at least 6 characters. ";    }    const hasErrors = Object.values(errors).some(msg => msg)    if (!hasErrors) {      await registerUser({name, email, password});      return Astro.redirect("/login");    }  } catch (error) {    if (error instanceof Error) {      console.error(error.message);    }  }}---<h1>Register</h1><form method="POST">  <label>    Username:    <input type="text" name="username" />  </label>  {errors.username && <p>{errors.username}</p>}  <label>    Email:    <input type="email" name="email" required />  </label>  {errors.email && <p>{errors.email}</p>}  <label>    Password:    <input type="password" name="password" required minlength="6" />  </label>  {errors.password && <p>{errors.password}</p>}  <button>Register</button></form>
    

Recipes

![](/_astro/CodingInPublic.DpaYu7Qd_5sx41.webp)

Learn Astro with **Coding in Public**
-------------------------------------

150+ video lessons • Astro v5 ready

[Get 20% off](https://learnastro.dev?code=ASTRO_PROMO)

document.querySelectorAll("a\[data-learn-astro-cta\]").forEach(a=>a.addEventListener("click",()=>{window.fathom?.trackEvent("Docs: Coding in Public campaign click")}));

[Edit page](https://github.com/withastro/docs/edit/main/src/content/docs/en/recipes/build-forms.mdx) [Translate this page](https://contribute.docs.astro.build/guides/i18n/)

[Previous  
Build a custom image component](/en/recipes/build-custom-img-component/) [Next  
Build forms with API routes](/en/recipes/build-forms-api/)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)



# Aggregated from ./pages/recipes/bun
Use Bun with Astro
==================

[Bun](https://bun.sh/) is an all-in-one JavaScript runtime & toolkit. See [Bun’s documentation](https://bun.sh/docs) for more information.

Caution

Using Bun with Astro may reveal rough edges. Some integrations may not work as expected. Consult [Bun’s official documentation for working with Astro](https://bun.sh/guides/ecosystem/astro) for details.

If you have any problems using Bun, please [open an Issue on GitHub with Bun directly](https://github.com/oven-sh/bun/issues/new/choose).

Prerequisites
-------------

[Section titled Prerequisites](#prerequisites)

*   Bun installed locally on your machine. See the [installation instructions](https://bun.sh/docs/installation) in Bun’s official documentation.

Create a new Astro project with Bun
-----------------------------------

[Section titled Create a new Astro project with Bun](#create-a-new-astro-project-with-bun)

Create a new Astro project with Bun using the following `create-astro` command:

Terminal window

    bunx create-astro@latest my-astro-project-using-bun

Tip

You may also [create a new Astro project from any existing Astro GitHub repository](/en/install-and-setup/#install-from-the-cli-wizard) using the `--template` flag:

Terminal window

    bunx create-astro@latest my-astro-project-using-bun --template eliancodes/brutal

Install dependencies
--------------------

[Section titled Install dependencies](#install-dependencies)

If you’re starting a new project using `bunx create-astro`, the CLI will automatically use Bun to install dependencies and you can skip this step.

Otherwise, you’ll need to install your dependencies with Bun:

Terminal window

    bun install

Add Types
---------

[Section titled Add Types](#add-types)

Bun publishes the [`@types/bun`](https://www.npmjs.com/package/@types/bun) package, containing the runtime types for Bun.

Install `@types/bun` using the following command:

Terminal window

    bun add -d @types/bun

Using Astro integrations
------------------------

[Section titled Using Astro integrations](#using-astro-integrations)

You can also use any of the official Astro integrations with the `astro add` command:

Terminal window

    bunx astro add react

Run Astro with Bun
------------------

[Section titled Run Astro with Bun](#run-astro-with-bun)

Note

Use the [`--bun` CLI flag](https://bun.sh/docs/cli/bunx#shebangs) before every `astro` command to use Bun’s own runtime in place of Node.

### Run the development server

[Section titled Run the development server](#run-the-development-server)

To run the development server using Bun as the runtime, use the following command:

Terminal window

    bunx --bun astro dev

### Building your site with Bun

[Section titled Building your site with Bun](#building-your-site-with-bun)

To build your site using Bun as the runtime, use the following command:

Terminal window

    bunx --bun astro build

Astro will output your site to the `dist/` directory. Then, you can serve your site using the `preview` command:

Terminal window

    bunx --bun astro preview

Add SSR with Bun
----------------

[Section titled Add SSR with Bun](#add-ssr-with-bun)

Since Bun features [Node.js API compatibility](https://bun.sh/docs/runtime/nodejs-apis), you can use any Astro adapter for [on-demand rendering](/en/guides/on-demand-rendering/) with your Astro project:

Terminal window

    bunx astro add vercel

Testing in Bun
--------------

[Section titled Testing in Bun](#testing-in-bun)

Bun ships with a fast, built-in, Jest-compatible test runner through the `bun test` command. If you like to use that read [`bun test` documentation](https://bun.sh/docs/cli/test).

However, it is also possible to use Cypress or Playwright for a modern approach to testing web apps.

### Cypress

[Section titled Cypress](#cypress)

Cypress is a front-end testing tool and is on a mission to “make the testing experience enjoyable and generate developer happiness”. This enables you to write end-to-end tests for your Astro site.

Install Cypress with the following command:

Terminal window

    bun add cypress --dev

For the rest of the configuration and to start your first test, follow the rest of Cypress process in the [Astro Testing Guide](/en/guides/testing/#configuration).

### Playwright

[Section titled Playwright](#playwright)

Playwright is an end-to-end testing framework that allows you to test your Astro code on all modern rendering engines including Chromium, WebKit, and Firefox.

Install Playwright using the following command:

Terminal window

    bun create playwright

To create your first Playwright test, follow the instructions for the rest of the Playwright process in the [Astro Testing Guide](/en/guides/testing/#create-your-first-playwright-test).

Official Resources
------------------

[Section titled Official Resources](#official-resources)

*   [Build an app with Astro and Bun](https://bun.sh/guides/ecosystem/astro)

Community Resources
-------------------

[Section titled Community Resources](#community-resources)

Using Bun with Astro? Add your blog post or video to this page!

*   [Building a Cloudflare Pages site with Bun](https://blog.otterlord.dev/posts/hello-from-bun/) - blog post
*   [Using Bun with Astro and Cloudflare Pages](https://handerson.hashnode.dev/using-bun-with-astro-and-cloudflare-pages) - blog post

Recipes

![](/_astro/CodingInPublic.DpaYu7Qd_5sx41.webp)

Learn Astro with **Coding in Public**
-------------------------------------

150+ video lessons • Astro v5 ready

[Get 20% off](https://learnastro.dev?code=ASTRO_PROMO)

document.querySelectorAll("a\[data-learn-astro-cta\]").forEach(a=>a.addEventListener("click",()=>{window.fathom?.trackEvent("Docs: Coding in Public campaign click")}));

[Edit page](https://github.com/withastro/docs/edit/main/src/content/docs/en/recipes/bun.mdx) [Translate this page](https://contribute.docs.astro.build/guides/i18n/)

[Previous  
Build forms with API routes](/en/recipes/build-forms-api/) [Next  
Call endpoints from the server](/en/recipes/call-endpoints/)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)



# Aggregated from ./pages/recipes/call-endpoints
Call endpoints from the server
==============================

Endpoints can be used to serve many kinds of data. This recipe calls a server endpoint from a page’s component script to display a greeting, without requiring an additional fetch request.

Prerequisites
-------------

[Section titled Prerequisites](#prerequisites)

*   A project with [SSR](/en/guides/on-demand-rendering/) (output: ‘server’) enabled

Recipe
------

[Section titled Recipe](#recipe)

1.  Create an endpoint in a new file `src/pages/api/hello.ts` that returns some data:
    
    src/pages/api/hello.ts
    
        import type { APIRoute } from 'astro'
        export const GET: APIRoute = () => {  return new Response(    JSON.stringify({      greeting: 'Hello',    }),  )}
    
2.  On any Astro page, import the `GET()` method from the endpoint. Call it with the [`Astro` global](/en/reference/api-reference/) to provide the request context, and use the response on the page:
    
    src/pages/index.astro
    
        ---import { GET } from './api/hello.ts'
        let response = await GET(Astro)const data = await response.json()---
        <h1>{data.greeting} world!</h1>
    

Recipes

![](/_astro/CodingInPublic.DpaYu7Qd_5sx41.webp)

Learn Astro with **Coding in Public**
-------------------------------------

150+ video lessons • Astro v5 ready

[Get 20% off](https://learnastro.dev?code=ASTRO_PROMO)

document.querySelectorAll("a\[data-learn-astro-cta\]").forEach(a=>a.addEventListener("click",()=>{window.fathom?.trackEvent("Docs: Coding in Public campaign click")}));

[Edit page](https://github.com/withastro/docs/edit/main/src/content/docs/en/recipes/call-endpoints.mdx) [Translate this page](https://contribute.docs.astro.build/guides/i18n/)

[Previous  
Use Bun with Astro](/en/recipes/bun/) [Next  
Verify a Captcha](/en/recipes/captcha/)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)



# Aggregated from ./pages/recipes/captcha
Verify a Captcha
================

[Server endpoints](/en/guides/endpoints/#server-endpoints-api-routes) can be used as REST API endpoints to run functions such as authentications, database access, and verifications without exposing sensitive data to the client.

In this recipe, an API route is used to verify Google reCAPTCHA v3 without exposing the secret to clients.

Prerequisites
-------------

[Section titled Prerequisites](#prerequisites)

*   A project with [SSR](/en/guides/on-demand-rendering/) (`output: 'server'`) enabled

Recipe
------

[Section titled Recipe](#recipe)

1.  Create a `POST` endpoint that accepts recaptcha data, then verifies it with reCAPTCHA’s API. Here, you can safely define secret values or read environment variables.
    
    src/pages/recaptcha.js
    
        export async function POST({ request }) {  const data = await request.json();
          const recaptchaURL = 'https://www.google.com/recaptcha/api/siteverify';  const requestHeaders = {    'Content-Type': 'application/x-www-form-urlencoded'  };  const requestBody = new URLSearchParams({    secret: "YOUR_SITE_SECRET_KEY",   // This can be an environment variable    response: data.recaptcha          // The token passed in from the client  });
          const response = await fetch(recaptchaURL, {    method: "POST",    headers: requestHeaders,    body: requestBody.toString()  });
          const responseData = await response.json();
          return new Response(JSON.stringify(responseData), { status: 200 });}
    
2.  Access your endpoint using `fetch` from a client script:
    
    src/pages/index.astro
    
        <html>  <head>    <script is:inline src="https://www.google.com/recaptcha/api.js"></script>  </head>
          <body>    <button class="g-recaptcha"      data-sitekey="PUBLIC_SITE_KEY"      data-callback="onSubmit"      data-action="submit"> Click me to verify the captcha challenge! </button>
            <script is:inline>      function onSubmit(token) {        fetch("/recaptcha", {          method: "POST",          body: JSON.stringify({ recaptcha: token })        })        .then((response) => response.json())        .then((gResponse) => {          if (gResponse.success) {            // Captcha verification was a success          } else {            // Captcha verification failed          }        })      }    </script>  </body></html>
    

Recipes

![](/_astro/CodingInPublic.DpaYu7Qd_5sx41.webp)

Learn Astro with **Coding in Public**
-------------------------------------

150+ video lessons • Astro v5 ready

[Get 20% off](https://learnastro.dev?code=ASTRO_PROMO)

document.querySelectorAll("a\[data-learn-astro-cta\]").forEach(a=>a.addEventListener("click",()=>{window.fathom?.trackEvent("Docs: Coding in Public campaign click")}));

[Edit page](https://github.com/withastro/docs/edit/main/src/content/docs/en/recipes/captcha.mdx) [Translate this page](https://contribute.docs.astro.build/guides/i18n/)

[Previous  
Call endpoints from the server](/en/recipes/call-endpoints/) [Next  
Build your Astro site with Docker](/en/recipes/docker/)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)



# Aggregated from ./pages/recipes/docker
Build your Astro site with Docker
=================================

[Docker](https://docker.com) is a tool to build, deploy, and run applications using containers.

Docker images and containers can be deployed to many different platforms, like AWS, Azure, and [Google Cloud](/en/guides/deploy/google-cloud/#cloud-run-ssr-and-static). This recipe won’t cover how to deploy your site to a specific platform but will show you how to set up Docker for your project.

Prerequisites
-------------

[Section titled Prerequisites](#prerequisites)

*   Docker installed on your local machine. You can find [installation instructions for your operating system here](https://docs.docker.com/get-docker/).
*   A Dockerfile in your project. You can [learn more about Dockerfiles here](https://docs.docker.com/engine/reference/builder/) and use the Dockerfiles in the following section as a starting point.

Creating a Dockerfile
---------------------

[Section titled Creating a Dockerfile](#creating-a-dockerfile)

Create a file called `Dockerfile` in your project’s root directory. This file contains the instructions to build your site, which will differ depending on your needs. This guide can’t show all possible options but will give you starting points for SSR and static mode.

If you’re using another package manager than npm, you’ll need to adjust the commands accordingly.

### SSR

[Section titled SSR](#ssr)

This Dockerfile will build your site and serve it using Node.js on port `4321` and therefore requires the [Node adapter](/en/guides/integrations-guide/node/) installed in your Astro project.

Dockerfile

    FROM node:lts AS runtimeWORKDIR /app
    COPY . .
    RUN npm installRUN npm run build
    ENV HOST=0.0.0.0ENV PORT=4321EXPOSE 4321CMD node ./dist/server/entry.mjs

Keep this in mind

These are just examples of Dockerfiles. You can customize them to your needs. For example, you could use another image, like `node:lts-alpine`:

Dockerfile

    FROM node:lts as runtimeFROM node:lts-alpine as runtime

### Adding a .dockerignore

[Section titled Adding a .dockerignore](#adding-a-dockerignore)

Adding a `.dockerignore` file to your project is best practice. This file describes which files or folders should be ignored in the Docker `COPY` or `ADD` commands, very similar to how `.gitignore` works. This speeds up the build process and reduces the size of the final image.

.dockerignore

    .DS_Storenode_modulesdist

This file should go in the same directory as the `Dockerfile` itself. [Read the `.dockerignore` documentation for extra info](https://docs.docker.com/engine/reference/builder/#dockerignore-file)

### Static

[Section titled Static](#static)

#### Apache (httpd)

[Section titled Apache (httpd)](#apache-httpd)

The following Dockerfile will build your site and serve it using Apache httpd on port `80` with the default configuration.

Dockerfile

    FROM node:lts AS buildWORKDIR /appCOPY . .RUN npm iRUN npm run build
    FROM httpd:2.4 AS runtimeCOPY --from=build /app/dist /usr/local/apache2/htdocs/EXPOSE 80

Recommendation

Use this approach for simple websites that don’t need any special configuration. For more complex websites, it is recommended to use a custom configuration, either in Apache or NGINX.

#### NGINX

[Section titled NGINX](#nginx)

Dockerfile

    FROM node:lts AS buildWORKDIR /appCOPY package*.json ./RUN npm installCOPY . .RUN npm run build
    FROM nginx:alpine AS runtimeCOPY ./nginx/nginx.conf /etc/nginx/nginx.confCOPY --from=build /app/dist /usr/share/nginx/htmlEXPOSE 8080

In order to build the Dockerfile above, you’ll also need to create a configuration file for NGINX. Create a folder called `nginx` in your project’s root directory and create a file called `nginx.conf` inside.

nginx.conf

    worker_processes  1;
    events {  worker_connections  1024;}
    http {  server {    listen 8080;    server_name   _;
        root   /usr/share/nginx/html;    index  index.html index.htm;    include /etc/nginx/mime.types;
        gzip on;    gzip_min_length 1000;    gzip_proxied expired no-cache no-store private auth;    gzip_types text/plain text/css application/json application/javascript application/x-javascript text/xml application/xml application/xml+rss text/javascript;
        error_page 404 /404.html;    location = /404.html {            root /usr/share/nginx/html;            internal;    }
        location / {            try_files $uri $uri/index.html =404;    }  }}

### Multi-stage build (using SSR)

[Section titled Multi-stage build (using SSR)](#multi-stage-build-using-ssr)

Here’s an example of a more advanced Dockerfile that, thanks to Docker’s [multi-stage builds](https://docs.docker.com/build/building/multi-stage/), optimizes the build process for your site by not reinstalling the npm dependencies when only the source code changes. This can reduce the build time even by minutes, depending on the size of your dependencies.

Dockerfile

    FROM node:lts AS baseWORKDIR /app
    # By copying only the package.json and package-lock.json here, we ensure that the following `-deps` steps are independent of the source code.# Therefore, the `-deps` steps will be skipped if only the source code changes.COPY package.json package-lock.json ./
    FROM base AS prod-depsRUN npm install --omit=dev
    FROM base AS build-depsRUN npm install
    FROM build-deps AS buildCOPY . .RUN npm run build
    FROM base AS runtimeCOPY --from=prod-deps /app/node_modules ./node_modulesCOPY --from=build /app/dist ./dist
    ENV HOST=0.0.0.0ENV PORT=4321EXPOSE 4321CMD node ./dist/server/entry.mjs

Recipe
------

[Section titled Recipe](#recipe)

1.  Build your container by running the following command in your project’s root directory. Use any name for `<your-astro-image-name>`:
    
    Terminal window
    
        docker build -t <your-astro-image-name> .
    
    This will output an image, which you can run locally or deploy to a platform of your choice.
    
2.  To run your image as a local container, use the following command.
    
    Replace `<local-port>` with an open port on your machine. Replace `<container-port>` with the port exposed by your Docker container (`4321`, `80`, or `8080` in the above examples.)
    
    Terminal window
    
        docker run -p <local-port>:<container-port> <your-astro-image-name>
    
    You should be able to access your site at `http://localhost:<local-port>`.
    
3.  Now that your website is successfully built and packaged in a container, you can deploy it to a cloud provider. See the [Google Cloud](/en/guides/deploy/google-cloud/#cloud-run-ssr-and-static) deployment guide for one example, and the [Deploy your app](https://docs.docker.com/language/nodejs/deploy/) page in the Docker docs.
    

Recipes

![](/_astro/CodingInPublic.DpaYu7Qd_5sx41.webp)

Learn Astro with **Coding in Public**
-------------------------------------

150+ video lessons • Astro v5 ready

[Get 20% off](https://learnastro.dev?code=ASTRO_PROMO)

document.querySelectorAll("a\[data-learn-astro-cta\]").forEach(a=>a.addEventListener("click",()=>{window.fathom?.trackEvent("Docs: Coding in Public campaign click")}));

[Edit page](https://github.com/withastro/docs/edit/main/src/content/docs/en/recipes/docker.mdx) [Translate this page](https://contribute.docs.astro.build/guides/i18n/)

[Previous  
Verify a Captcha](/en/recipes/captcha/) [Next  
Dynamically import images](/en/recipes/dynamically-importing-images/)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)



# Aggregated from ./pages/recipes/dynamically-importing-images
Dynamically import images
=========================

Local [images](/en/guides/images/) must be imported into `.astro` files in order to display them. There will be times where you will want or need to dynamically import the image paths of your images instead of explicitly importing each individual image.

In this recipe, you will learn how to dynamically import your images using Vite’s `import.meta.glob` function. You will build a card component that displays the name, age, and photo of a person.

Recipe
------

[Section titled Recipe](#recipe)

1.  Create a new `assets` folder under the `src` directory and add your images inside that new folder.
    
    *   Directorysrc/
        
        *   Directoryassets/
            
            *   avatar-1.jpg
            *   avatar-2.png
            *   avatar-3.jpeg
            
        
    
    Note
    
    `assets` is a popular folder name convention for placing images but you are free to name the folder whatever you like.
    
2.  Create a new Astro component for your card and import the `<Image />` component.
    
    src/components/MyCustomCardComponent.astro
    
        ---import { Image } from 'astro:assets';---
    
3.  Specify the `props` that your component will receive in order to display the necessary information on each card. You can optionally define their types, if you are using TypeScript in your project.
    
    src/components/MyCustomCardComponent.astro
    
        ---import { Image } from 'astro:assets';
        interface Props {   imagePath: string;   altText: string;   name: string;   age: number;}
        const { imagePath, altText, name, age } = Astro.props;---
    
4.  Create a new `images` variable and use the `import.meta.glob` function which returns an object of all of the image paths inside the `assets` folder. You will also need to import `ImageMetadata` type to help define the type of the `images` variable.
    
    src/components/MyCustomCardComponent.astro
    
        ---import type { ImageMetadata } from 'astro';import { Image } from 'astro:assets';
        interface Props {   imagePath: string;   altText: string;   name: string;   age: number;}
        const { imagePath, altText, name, age } = Astro.props;const images = import.meta.glob<{ default: ImageMetadata }>('/src/assets/*.{jpeg,jpg,png,gif}')---
    
5.  Use the props to create the markup for your card component.
    
    src/components/MyCustomCardComponent.astro
    
        ---import type { ImageMetadata } from 'astro';import { Image } from 'astro:assets';
        interface Props {   imagePath: string;   altText: string;   name: string;   age: number;}
        const { imagePath, altText, name, age } = Astro.props;const images = import.meta.glob<{ default: ImageMetadata }>('/src/assets/*.{jpeg,jpg,png,gif}');---<div class="card">    <h2>{name}</h2>    <p>Age: {age}</p>    <Image src={} alt={altText} /></div>
    
6.  Inside the `src` attribute, pass in the `images` object and use bracket notation for the image path. Then make sure to invoke the glob function.
    
    Since you are accessing the `images` object which has an unknown type, you should also `throw` an error in case an invalid file path is passed as a prop.
    
    src/components/MyCustomCardComponent.astro
    
        ---import type { ImageMetadata } from 'astro';import { Image } from 'astro:assets';
        interface Props {   imagePath: string;   altText: string;   name: string;   age: number;}
        const { imagePath, altText, name, age } = Astro.props;const images = import.meta.glob<{ default: ImageMetadata }>('/src/assets/*.{jpeg,jpg,png,gif}');if (!images[imagePath]) throw new Error(`"${imagePath}" does not exist in glob: "src/assets/*.{jpeg,jpg,png,gif}"`);---<div class="card">    <h2>{name}</h2>    <p>Age: {age}</p>    <Image src={images[imagePath]()} alt={altText} /></div>
    
    Note
    
    `images` is an object that contains all of the image paths inside the `assets` folder.
    
        const images = {  './assets/avatar-1.jpg': () => import('./assets/avatar-1.jpg'),  './assets/avatar-2.png': () => import('./assets/avatar-2.png'),  './assets/avatar-3.jpeg': () => import('./assets/avatar-3.jpeg')}
    
    The `imagePath` prop is a string that contains the path to the image that you want to display. The `import.meta.glob()` is doing the work of finding the image path that matches the `imagePath` prop and handling the import for you.
    
7.  Import and use the card component inside an Astro page, passing in the values for the `props`.
    
    src/pages/index.astro
    
        ---import MyCustomCardComponent from '../components/MyCustomCardComponent.astro';---<MyCustomCardComponent    imagePath="/src/assets/avatar-1.jpg"    altText="A headshot of Priya against a brick wall background."    name="Priya"    age={25}/>
    

Recipes

![](/_astro/CodingInPublic.DpaYu7Qd_5sx41.webp)

Learn Astro with **Coding in Public**
-------------------------------------

150+ video lessons • Astro v5 ready

[Get 20% off](https://learnastro.dev?code=ASTRO_PROMO)

document.querySelectorAll("a\[data-learn-astro-cta\]").forEach(a=>a.addEventListener("click",()=>{window.fathom?.trackEvent("Docs: Coding in Public campaign click")}));

[Edit page](https://github.com/withastro/docs/edit/main/src/content/docs/en/recipes/dynamically-importing-images.mdx) [Translate this page](https://contribute.docs.astro.build/guides/i18n/)

[Previous  
Build your Astro site with Docker](/en/recipes/docker/) [Next  
Add icons to external links](/en/recipes/external-links/)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)



# Aggregated from ./pages/recipes/external-links
Add icons to external links
===========================

Using a rehype plugin, you can identify and modify links in your Markdown files that point to external sites. This example adds icons to the end of each external link, so that visitors will know they are leaving your site.

Prerequisites
-------------

[Section titled Prerequisites](#prerequisites)

*   An Astro project using Markdown for content pages.

Recipe
------

[Section titled Recipe](#recipe)

1.  Install the `rehype-external-links` plugin.
    
    (() => { class StarlightTabsRestore extends HTMLElement { connectedCallback() { const starlightTabs = this.closest('starlight-tabs'); if (!(starlightTabs instanceof HTMLElement) || typeof localStorage === 'undefined') return; const syncKey = starlightTabs.dataset.syncKey; if (!syncKey) return; const label = localStorage.getItem(\`starlight-synced-tabs\_\_${syncKey}\`); if (!label) return; const tabs = \[...starlightTabs?.querySelectorAll('\[role="tab"\]')\]; const tabIndexToRestore = tabs.findIndex( (tab) => tab instanceof HTMLAnchorElement && tab.textContent?.trim() === label ); const panels = starlightTabs?.querySelectorAll(':scope > \[role="tabpanel"\]'); const newTab = tabs\[tabIndexToRestore\]; const newPanel = panels\[tabIndexToRestore\]; if (tabIndexToRestore < 1 || !newTab || !newPanel) return; tabs\[0\]?.setAttribute('aria-selected', 'false'); tabs\[0\]?.setAttribute('tabindex', '-1'); panels?.\[0\]?.setAttribute('hidden', 'true'); newTab.removeAttribute('tabindex'); newTab.setAttribute('aria-selected', 'true'); newPanel.removeAttribute('hidden'); } } customElements.define('starlight-tabs-restore', StarlightTabsRestore); })()
    
    *   [npm](#tab-panel-1774)
    *   [pnpm](#tab-panel-1775)
    *   [Yarn](#tab-panel-1776)
    
    Terminal window
    
        npm install rehype-external-links
    
    Terminal window
    
        pnpm add rehype-external-links
    
    Terminal window
    
        yarn add rehype-external-links
    
    class r extends HTMLElement{static#e=new Map;#t;#n="starlight-synced-tabs\_\_";constructor(){super();const t=this.querySelector('\[role="tablist"\]');if(this.tabs=\[...t.querySelectorAll('\[role="tab"\]')\],this.panels=\[...this.querySelectorAll(':scope > \[role="tabpanel"\]')\],this.#t=this.dataset.syncKey,this.#t){const i=r.#e.get(this.#t)??\[\];i.push(this),r.#e.set(this.#t,i)}this.tabs.forEach((i,c)=>{i.addEventListener("click",e=>{e.preventDefault();const n=t.querySelector('\[aria-selected="true"\]');e.currentTarget!==n&&this.switchTab(e.currentTarget,c)}),i.addEventListener("keydown",e=>{const n=this.tabs.indexOf(e.currentTarget),s=e.key==="ArrowLeft"?n-1:e.key==="ArrowRight"?n+1:e.key==="Home"?0:e.key==="End"?this.tabs.length-1:null;s!==null&&this.tabs\[s\]&&(e.preventDefault(),this.switchTab(this.tabs\[s\],s))})})}switchTab(t,i,c=!0){if(!t)return;const e=c?this.getBoundingClientRect().top:0;this.tabs.forEach(s=>{s.setAttribute("aria-selected","false"),s.setAttribute("tabindex","-1")}),this.panels.forEach(s=>{s.hidden=!0});const n=this.panels\[i\];n&&(n.hidden=!1),t.removeAttribute("tabindex"),t.setAttribute("aria-selected","true"),c&&(t.focus(),r.#r(this,t),window.scrollTo({top:window.scrollY+(this.getBoundingClientRect().top-e),behavior:"instant"}))}#i(t){!this.#t||typeof localStorage>"u"||localStorage.setItem(this.#n+this.#t,t)}static#r(t,i){const c=t.#t,e=r.#s(i);if(!c||!e)return;const n=r.#e.get(c);if(n){for(const s of n){if(s===t)continue;const a=s.tabs.findIndex(o=>r.#s(o)===e);a!==-1&&s.switchTab(s.tabs\[a\],a,!1)}t.#i(e)}}static#s(t){return t.textContent?.trim()}}customElements.define("starlight-tabs",r);
2.  Import the plugin into your `astro.config.mjs` file.
    
    Pass `rehypeExternalLinks` to the `rehypePlugins` array, along with an options object that includes a content property. Set this property’s `type` to `text` if you want to add plain text to the end of the link. To add HTML to the end of the link instead, set the property `type` to `raw`.
    
        // ...import rehypeExternalLinks from 'rehype-external-links';
        export default defineConfig({  // ...  markdown: {    rehypePlugins: [      [        rehypeExternalLinks,        {          content: { type: 'text', value: ' 🔗' }        }      ],    ]  },});
    
    Note
    
    The value of the `content` property is [not represented in the accessibility tree](https://developer.mozilla.org/en-US/docs/Web/CSS/content#accessibility_concerns). As such, it’s best to make clear that the link is external in the surrounding content, rather than relying on the icon alone.
    

Resources
---------

[Section titled Resources](#resources)

*   [rehype-external-links](https://www.npmjs.com/package/rehype-external-links)

Recipes

![](/_astro/CodingInPublic.DpaYu7Qd_5sx41.webp)

Learn Astro with **Coding in Public**
-------------------------------------

150+ video lessons • Astro v5 ready

[Get 20% off](https://learnastro.dev?code=ASTRO_PROMO)

document.querySelectorAll("a\[data-learn-astro-cta\]").forEach(a=>a.addEventListener("click",()=>{window.fathom?.trackEvent("Docs: Coding in Public campaign click")}));

[Edit page](https://github.com/withastro/docs/edit/main/src/content/docs/en/recipes/external-links.mdx) [Translate this page](https://contribute.docs.astro.build/guides/i18n/)

[Previous  
Dynamically import images](/en/recipes/dynamically-importing-images/) [Next  
Add i18n features](/en/recipes/i18n/)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)



# Aggregated from ./pages/recipes/i18n
Add i18n features
=================

In this recipe, you will learn how to use content collections and dynamic routing to build your own internationalization (i18n) solution and serve your content in different languages.

Tip

In v4.0, Astro added built-in support for i18n routing that allows you to configure default and supported languages and includes valuable helper functions to assist you in serving an international audience. If you want to use this instead, see our [internationalization guide](/en/guides/internationalization/) to learn about these features.

This example serves each language at its own subpath, e.g. `example.com/en/blog` for English and `example.com/fr/blog` for French.

If you prefer the default language to not be visible in the URL unlike other languages, there are [instructions to hide the default language](/en/recipes/i18n/#hide-default-language-in-the-url) below.

See the [resources section](#resources) for external links to related topics such as right-to-left (RTL) styling and choosing language tags.

Recipe
------

[Section titled Recipe](#recipe)

### Set up pages for each language

[Section titled Set up pages for each language](#set-up-pages-for-each-language)

1.  Create a directory for each language you want to support. For example, `en/` and `fr/` if you are supporting English and French:
    
    *   Directorysrc/
        
        *   Directorypages/
            
            *   Directory**en/**
                
                *   about.astro
                *   index.astro
                
            *   Directory**fr/**
                
                *   about.astro
                *   index.astro
                
            *   index.astro
            
        
    
2.  Set up `src/pages/index.astro` to redirect to your default language.
    
    (() => { class StarlightTabsRestore extends HTMLElement { connectedCallback() { const starlightTabs = this.closest('starlight-tabs'); if (!(starlightTabs instanceof HTMLElement) || typeof localStorage === 'undefined') return; const syncKey = starlightTabs.dataset.syncKey; if (!syncKey) return; const label = localStorage.getItem(\`starlight-synced-tabs\_\_${syncKey}\`); if (!label) return; const tabs = \[...starlightTabs?.querySelectorAll('\[role="tab"\]')\]; const tabIndexToRestore = tabs.findIndex( (tab) => tab instanceof HTMLAnchorElement && tab.textContent?.trim() === label ); const panels = starlightTabs?.querySelectorAll(':scope > \[role="tabpanel"\]'); const newTab = tabs\[tabIndexToRestore\]; const newPanel = panels\[tabIndexToRestore\]; if (tabIndexToRestore < 1 || !newTab || !newPanel) return; tabs\[0\]?.setAttribute('aria-selected', 'false'); tabs\[0\]?.setAttribute('tabindex', '-1'); panels?.\[0\]?.setAttribute('hidden', 'true'); newTab.removeAttribute('tabindex'); newTab.setAttribute('aria-selected', 'true'); newPanel.removeAttribute('hidden'); } } customElements.define('starlight-tabs-restore', StarlightTabsRestore); })()
    
    *   [Static](#tab-panel-1777)
    *   [On demand](#tab-panel-1778)
    
    src/pages/index.astro
    
        <meta http-equiv="refresh" content="0;url=/en/" />
    
    This approach uses a [meta refresh](https://en.wikipedia.org/wiki/Meta_refresh) and will work however you deploy your site. Some static hosts also let you configure server redirects with a custom configuration file. See your deploy platform’s documentation for more details.
    
    If you are using an SSR adapter, you can use [`Astro.redirect`](/en/guides/routing/#dynamic-redirects) to redirect to the default language on the server.
    
    src/pages/index.astro
    
        ---return Astro.redirect('/en/');---
    
    class r extends HTMLElement{static#e=new Map;#t;#n="starlight-synced-tabs\_\_";constructor(){super();const t=this.querySelector('\[role="tablist"\]');if(this.tabs=\[...t.querySelectorAll('\[role="tab"\]')\],this.panels=\[...this.querySelectorAll(':scope > \[role="tabpanel"\]')\],this.#t=this.dataset.syncKey,this.#t){const i=r.#e.get(this.#t)??\[\];i.push(this),r.#e.set(this.#t,i)}this.tabs.forEach((i,c)=>{i.addEventListener("click",e=>{e.preventDefault();const n=t.querySelector('\[aria-selected="true"\]');e.currentTarget!==n&&this.switchTab(e.currentTarget,c)}),i.addEventListener("keydown",e=>{const n=this.tabs.indexOf(e.currentTarget),s=e.key==="ArrowLeft"?n-1:e.key==="ArrowRight"?n+1:e.key==="Home"?0:e.key==="End"?this.tabs.length-1:null;s!==null&&this.tabs\[s\]&&(e.preventDefault(),this.switchTab(this.tabs\[s\],s))})})}switchTab(t,i,c=!0){if(!t)return;const e=c?this.getBoundingClientRect().top:0;this.tabs.forEach(s=>{s.setAttribute("aria-selected","false"),s.setAttribute("tabindex","-1")}),this.panels.forEach(s=>{s.hidden=!0});const n=this.panels\[i\];n&&(n.hidden=!1),t.removeAttribute("tabindex"),t.setAttribute("aria-selected","true"),c&&(t.focus(),r.#r(this,t),window.scrollTo({top:window.scrollY+(this.getBoundingClientRect().top-e),behavior:"instant"}))}#i(t){!this.#t||typeof localStorage>"u"||localStorage.setItem(this.#n+this.#t,t)}static#r(t,i){const c=t.#t,e=r.#s(i);if(!c||!e)return;const n=r.#e.get(c);if(n){for(const s of n){if(s===t)continue;const a=s.tabs.findIndex(o=>r.#s(o)===e);a!==-1&&s.switchTab(s.tabs\[a\],a,!1)}t.#i(e)}}static#s(t){return t.textContent?.trim()}}customElements.define("starlight-tabs",r);

### Use collections for translated content

[Section titled Use collections for translated content](#use-collections-for-translated-content)

1.  Create a folder in `src/content/` for each type of content you want to include and add subdirectories for each supported language. For example, to support English and French blog posts:
    
    *   Directorysrc/
        
        *   Directorycontent/
            
            *   Directoryblog/
                
                *   Directory**en/** Blog posts in English
                    
                    *   post-1.md
                    *   post-2.md
                    
                *   Directory**fr/** Blog posts in French
                    
                    *   post-1.md
                    *   post-2.md
                    
                
            
        
    
2.  Create a `src/content.config.ts` file and export a collection for each type of content.
    
    src/content.config.ts
    
        import { defineCollection, z } from 'astro:content';
        const blogCollection = defineCollection({  schema: z.object({    title: z.string(),    author: z.string(),    date: z.date()  })});
        export const collections = {  'blog': blogCollection};
    
    Read more about [Content Collections](/en/guides/content-collections/).
    
3.  Use [dynamic routes](/en/guides/routing/#dynamic-routes) to fetch and render content based on a `lang` and a `slug` parameter.
    
    *   [Static](#tab-panel-1779)
    *   [On demand](#tab-panel-1780)
    
    In static rendering mode, use `getStaticPaths` to map each content entry to a page:
    
    src/pages/\[lang\]/blog/\[...slug\].astro
    
        ---import { getCollection, render } from 'astro:content';
        export async function getStaticPaths() {  const pages = await getCollection('blog');
          const paths = pages.map(page => {    const [lang, ...slug] = page.id.split('/');    return { params: { lang, slug: slug.join('/') || undefined }, props: page };  });
          return paths;}
        const { lang, slug } = Astro.params;const page = Astro.props;const formattedDate = page.data.date.toLocaleString(lang);const { Content } = await render(page);---<h1>{page.data.title}</h1><p>by {page.data.author} • {formattedDate}</p><Content/>
    
    In [SSR mode](/en/guides/on-demand-rendering/), fetch the requested entry directly:
    
    src/pages/\[lang\]/blog/\[...slug\].astro
    
        ---import { getEntry, render } from 'astro:content';
        const { lang, slug } = Astro.params;const page = await getEntry('blog', `${lang}/${slug}`);
        if (!page) {  return Astro.redirect('/404');}
        const formattedDate = page.data.date.toLocaleString(lang);const { Content, headings } = await render(page);---<h1>{page.data.title}</h1><p>by {page.data.author} • {formattedDate}</p><Content/>
    
    Read more about [dynamic routing](/en/guides/routing/#dynamic-routes).
    
    Date formatting
    
    The example above uses the built-in [`toLocaleString()` date-formatting method](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleString) to create a human-readable string from the frontmatter date. This ensures the date and time are formatted to match the user’s language.
    

### Translate UI strings

[Section titled Translate UI strings](#translate-ui-strings)

Create dictionaries of terms to translate the labels for UI elements around your site. This allows your visitors to experience your site fully in their language.

1.  Create a `src/i18n/ui.ts` file to store your translation strings:
    
    src/i18n/ui.ts
    
        export const languages = {  en: 'English',  fr: 'Français',};
        export const defaultLang = 'en';
        export const ui = {  en: {    'nav.home': 'Home',    'nav.about': 'About',    'nav.twitter': 'Twitter',  },  fr: {    'nav.home': 'Accueil',    'nav.about': 'À propos',  },} as const;
    
2.  Create two helper functions: one to detect the page language based on the current URL, and one to get translations strings for different parts of the UI in `src/i18n/utils.ts`:
    
    src/i18n/utils.ts
    
        import { ui, defaultLang } from './ui';
        export function getLangFromUrl(url: URL) {  const [, lang] = url.pathname.split('/');  if (lang in ui) return lang as keyof typeof ui;  return defaultLang;}
        export function useTranslations(lang: keyof typeof ui) {  return function t(key: keyof typeof ui[typeof defaultLang]) {    return ui[lang][key] || ui[defaultLang][key];  }}
    
    Did you notice?
    
    In step 1, the `nav.twitter` string was not translated to French. You may not want every term translated, such as proper names or common industry terms. The `useTranslations` helper will return the default language’s value if a key is not translated. In this example, French users will also see “Twitter” in the nav bar.
    
3.  Import the helpers where needed and use them to choose the UI string that corresponds to the current language. For example, a nav component might look like:
    
    src/components/Nav.astro
    
        ---import { getLangFromUrl, useTranslations } from '../i18n/utils';
        const lang = getLangFromUrl(Astro.url);const t = useTranslations(lang);---<ul>    <li>        <a href={`/${lang}/home/`}>          {t('nav.home')}        </a>    </li>    <li>        <a href={`/${lang}/about/`}>          {t('nav.about')}        </a>    </li>    <li>        <a href="https://twitter.com/astrodotbuild">          {t('nav.twitter')}        </a>    </li></ul>
    
4.  Each page must have a `lang` attribute on the `<html>` element that matches the language on the page. In this example, a [reusable layout](/en/basics/layouts/) extracts the language from the current route:
    
    src/layouts/Base.astro
    
        ---import { getLangFromUrl } from '../i18n/utils';
        const lang = getLangFromUrl(Astro.url);---<html lang={lang}>    <head>        <meta charset="utf-8" />        <link rel="icon" type="image/svg+xml" href="/favicon.svg" />        <meta name="viewport" content="width=device-width" />        <title>Astro</title>    </head>    <body>        <slot />    </body></html>
    
    You can then use this base layout to ensure that pages use the correct `lang` attribute automatically.
    
    src/pages/en/about.astro
    
        ---import Base from '../../layouts/Base.astro';---<Base>    <h1>About me</h1>    ...</Base>
    

### Let users switch between languages

[Section titled Let users switch between languages](#let-users-switch-between-languages)

Create links to the different languages you support so users can choose the language they want to read your site in.

1.  Create a component to show a link for each language:
    
    src/components/LanguagePicker.astro
    
        ---import { languages } from '../i18n/ui';---<ul>  {Object.entries(languages).map(([lang, label]) => (    <li>      <a href={`/${lang}/`}>{label}</a>    </li>  ))}</ul>
    
2.  Add `<LanguagePicker />` to your site so it is shown on every page. The example below adds it to the site footer in a base layout:
    
    src/layouts/Base.astro
    
        ---import LanguagePicker from '../components/LanguagePicker.astro';import { getLangFromUrl } from '../i18n/utils';
        const lang = getLangFromUrl(Astro.url);---<html lang={lang}>    <head>        <meta charset="utf-8" />        <link rel="icon" type="image/svg+xml" href="/favicon.svg" />        <meta name="viewport" content="width=device-width" />        <title>Astro</title>    </head>    <body>        <slot />        <footer>          <LanguagePicker />        </footer>    </body></html>
    

### Hide default language in the URL

[Section titled Hide default language in the URL](#hide-default-language-in-the-url)

1.  Create a directory for each language except the default language. For example, store your default language pages directly in `pages/`, and your translated pages in `fr/`:
    
    *   Directorysrc/
        
        *   Directorypages/
            
            *   about.astro
            *   index.astro
            *   Directory**fr/**
                
                *   about.astro
                *   index.astro
                
            
        
    
2.  Add another line to the `src/i18n/ui.ts` file to toggle the feature:
    
    src/i18n/ui.ts
    
        export const showDefaultLang = false;
    
3.  Add a helper function to `src/i18n/utils.ts`, to translate paths based on the current language:
    
    src/i18n/utils.ts
    
        import { ui, defaultLang, showDefaultLang } from './ui';
        export function useTranslatedPath(lang: keyof typeof ui) {  return function translatePath(path: string, l: string = lang) {    return !showDefaultLang && l === defaultLang ? path : `/${l}${path}`  }}
    
4.  Import the helper where needed. For example, a `nav` component might look like:
    
    src/components/Nav.astro
    
        ---import { getLangFromUrl, useTranslations, useTranslatedPath } from '../i18n/utils';
        const lang = getLangFromUrl(Astro.url);const t = useTranslations(lang);const translatePath = useTranslatedPath(lang);---<ul>    <li>        <a href={translatePath('/home/')}>          {t('nav.home')}        </a>    </li>    <li>        <a href={translatePath('/about/')}>          {t('nav.about')}        </a>    </li>    <li>        <a href="https://twitter.com/astrodotbuild">          {t('nav.twitter')}        </a>    </li></ul>
    
5.  The helper function can also be used to translate paths for a specific language. For example, when users switch between languages:
    
    src/components/LanguagePicker.astro
    
        ---import { languages } from '../i18n/ui';import { getLangFromUrl, useTranslatedPath } from '../i18n/utils';
        const lang = getLangFromUrl(Astro.url);const translatePath = useTranslatedPath(lang);---<ul>  {Object.entries(languages).map(([lang, label]) => (    <li>      <a href={translatePath('/', lang)}>{label}</a>    </li>  ))}</ul>
    

### Translate Routes

[Section titled Translate Routes](#translate-routes)

Translate the routes of your pages for each language.

1.  Add route mappings to `src/i18n/ui.ts`:
    
    src/i18n/ui.ts
    
        export const routes = {  de: {    'services': 'leistungen',  },  fr: {    'services': 'prestations-de-service',  },}
    
2.  Update the `useTranslatedPath` helper function in `src/i18n/utils.ts` to add router translation logic.
    
    src/i18n/utils.ts
    
        import { ui, defaultLang, showDefaultLang, routes } from './ui';
        export function useTranslatedPath(lang: keyof typeof ui) {  return function translatePath(path: string, l: string = lang) {    const pathName = path.replaceAll('/', '')    const hasTranslation = defaultLang !== l && routes[l] !== undefined && routes[l][pathName] !== undefined    const translatedPath = hasTranslation ? '/' + routes[l][pathName] : path
            return !showDefaultLang && l === defaultLang ? translatedPath : `/${l}${translatedPath}`  }}
    
3.  Create a helper function to get the route, if it exists based on the current URL, in `src/i18n/utils.ts`:
    
    src/i18n/utils.ts
    
        import { ui, defaultLang, showDefaultLang, routes } from './ui';
        export function getRouteFromUrl(url: URL): string | undefined {  const pathname = new URL(url).pathname;  const parts = pathname?.split('/');  const path = parts.pop() || parts.pop();
          if (path === undefined) {    return undefined;  }
          const currentLang = getLangFromUrl(url);
          if (defaultLang === currentLang) {    const route = Object.values(routes)[0];    return route[path] !== undefined ? route[path] : undefined;  }
          const getKeyByValue = (obj: Record<string, string>, value: string): string | undefined  => {      return Object.keys(obj).find((key) => obj[key] === value);  }
          const reversedKey = getKeyByValue(routes[currentLang], path);
          if (reversedKey !== undefined) {    return reversedKey;  }
          return undefined;}
    
4.  The helper function can be used to get a translated route. For example, when no translated route is defined, the user will be redirected to the home page:
    
    src/components/LanguagePicker.astro
    
        ---import { languages } from '../i18n/ui';import { getRouteFromUrl, useTranslatedPath } from '../i18n/utils';
        const route = getRouteFromUrl(Astro.url);---<ul>  {Object.entries(languages).map(([lang, label]) => {    const translatePath = useTranslatedPath(lang);    return (      <li>        <a href={translatePath(`/${route ? route : ''}`)}>{label}</a>      </li>    )  })}</ul>
    

Resources
---------

[Section titled Resources](#resources)

*   [Choosing a Language Tag](https://www.w3.org/International/questions/qa-choosing-language-tags)
*   [Right-to-left (RTL) Styling 101](https://rtlstyling.com/)

Community libraries
-------------------

[Section titled Community libraries](#community-libraries)

*   [astro-i18next](https://github.com/yassinedoghri/astro-i18next) — An Astro integration for i18next including some utility components.
*   [astro-i18n](https://github.com/alexandre-fernandez/astro-i18n) — A TypeScript-first internationalization library for Astro.
*   [astro-i18n-aut](https://github.com/jlarmstrongiv/astro-i18n-aut) — An Astro integration for i18n that supports the `defaultLocale` without page generation. The integration is adapter agnostic and UI framework agnostic.
*   [astro-react-i18next](https://github.com/jeremyxgo/astro-react-i18next) — An Astro integration that seamlessly enables the use of i18next and react-i18next in React components on Astro websites.
*   [paraglide](https://inlang.com/c/astro) — A fully type-safe i18n library specifically designed for partial hydration patterns like Astro islands.
*   [astro-loader-i18n](https://github.com/openscript/astro-loader-i18n) — An Astro glob content loader for i18n files and folder structures supporting the translation of routes.

Recipes

![](/_astro/CodingInPublic.DpaYu7Qd_5sx41.webp)

Learn Astro with **Coding in Public**
-------------------------------------

150+ video lessons • Astro v5 ready

[Get 20% off](https://learnastro.dev?code=ASTRO_PROMO)

document.querySelectorAll("a\[data-learn-astro-cta\]").forEach(a=>a.addEventListener("click",()=>{window.fathom?.trackEvent("Docs: Coding in Public campaign click")}));

[Edit page](https://github.com/withastro/docs/edit/main/src/content/docs/en/recipes/i18n.mdx) [Translate this page](https://contribute.docs.astro.build/guides/i18n/)

[Previous  
Add icons to external links](/en/recipes/external-links/) [Next  
Create a dev toolbar app](/en/recipes/making-toolbar-apps/)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)



# Aggregated from ./pages/recipes/making-toolbar-apps
Create a dev toolbar app
========================

Astro includes a [development toolbar](/en/guides/dev-toolbar/) that you can use to inspect your site, check for accessibility and performance issues, and more. This toolbar can be extended with custom apps.

Build a motivational dev toolbar app
------------------------------------

[Section titled Build a motivational dev toolbar app](#build-a-motivational-dev-toolbar-app)

In this recipe, you’ll learn how to create a dev toolbar app that helps you stay motivated while working on your site. This app will display a motivational message every time you toggle it on.

Tip

Just want to get started quickly? Jump start your app by creating a new Astro project with the `toolbar-app` template.

(() => { class StarlightTabsRestore extends HTMLElement { connectedCallback() { const starlightTabs = this.closest('starlight-tabs'); if (!(starlightTabs instanceof HTMLElement) || typeof localStorage === 'undefined') return; const syncKey = starlightTabs.dataset.syncKey; if (!syncKey) return; const label = localStorage.getItem(\`starlight-synced-tabs\_\_${syncKey}\`); if (!label) return; const tabs = \[...starlightTabs?.querySelectorAll('\[role="tab"\]')\]; const tabIndexToRestore = tabs.findIndex( (tab) => tab instanceof HTMLAnchorElement && tab.textContent?.trim() === label ); const panels = starlightTabs?.querySelectorAll(':scope > \[role="tabpanel"\]'); const newTab = tabs\[tabIndexToRestore\]; const newPanel = panels\[tabIndexToRestore\]; if (tabIndexToRestore < 1 || !newTab || !newPanel) return; tabs\[0\]?.setAttribute('aria-selected', 'false'); tabs\[0\]?.setAttribute('tabindex', '-1'); panels?.\[0\]?.setAttribute('hidden', 'true'); newTab.removeAttribute('tabindex'); newTab.setAttribute('aria-selected', 'true'); newPanel.removeAttribute('hidden'); } } customElements.define('starlight-tabs-restore', StarlightTabsRestore); })()

*   [npm](#tab-panel-1781)
*   [pnpm](#tab-panel-1782)
*   [Yarn](#tab-panel-1783)

Terminal window

    npm create astro@latest -- --template toolbar-app

Terminal window

    pnpm create astro -- --template toolbar-app

Terminal window

    yarn create astro -- --template toolbar-app

class r extends HTMLElement{static#e=new Map;#t;#n="starlight-synced-tabs\_\_";constructor(){super();const t=this.querySelector('\[role="tablist"\]');if(this.tabs=\[...t.querySelectorAll('\[role="tab"\]')\],this.panels=\[...this.querySelectorAll(':scope > \[role="tabpanel"\]')\],this.#t=this.dataset.syncKey,this.#t){const i=r.#e.get(this.#t)??\[\];i.push(this),r.#e.set(this.#t,i)}this.tabs.forEach((i,c)=>{i.addEventListener("click",e=>{e.preventDefault();const n=t.querySelector('\[aria-selected="true"\]');e.currentTarget!==n&&this.switchTab(e.currentTarget,c)}),i.addEventListener("keydown",e=>{const n=this.tabs.indexOf(e.currentTarget),s=e.key==="ArrowLeft"?n-1:e.key==="ArrowRight"?n+1:e.key==="Home"?0:e.key==="End"?this.tabs.length-1:null;s!==null&&this.tabs\[s\]&&(e.preventDefault(),this.switchTab(this.tabs\[s\],s))})})}switchTab(t,i,c=!0){if(!t)return;const e=c?this.getBoundingClientRect().top:0;this.tabs.forEach(s=>{s.setAttribute("aria-selected","false"),s.setAttribute("tabindex","-1")}),this.panels.forEach(s=>{s.hidden=!0});const n=this.panels\[i\];n&&(n.hidden=!1),t.removeAttribute("tabindex"),t.setAttribute("aria-selected","true"),c&&(t.focus(),r.#r(this,t),window.scrollTo({top:window.scrollY+(this.getBoundingClientRect().top-e),behavior:"instant"}))}#i(t){!this.#t||typeof localStorage>"u"||localStorage.setItem(this.#n+this.#t,t)}static#r(t,i){const c=t.#t,e=r.#s(i);if(!c||!e)return;const n=r.#e.get(c);if(n){for(const s of n){if(s===t)continue;const a=s.tabs.findIndex(o=>r.#s(o)===e);a!==-1&&s.switchTab(s.tabs\[a\],a,!1)}t.#i(e)}}static#s(t){return t.textContent?.trim()}}customElements.define("starlight-tabs",r);

Or, keep reading to learn how to build an app from scratch.

### Creating the Astro integration

[Section titled Creating the Astro integration](#creating-the-astro-integration)

Dev toolbar apps can only be added by [Astro Integrations](/en/guides/integrations-guide/) using [the `astro:config:setup` hook](/en/reference/integrations-reference/#astroconfigsetup). You will need to create both a toolbar app and the integration that will add it to the toolbar of your existing Astro project.

1.  In the root of your existing Astro project, create a new folder named `my-toolbar-app/` for your app and integration files. Create two new files in this folder: `app.ts` and `my-integration.ts`.
    
    *   Directory**my-toolbar-app/**
        
        *   **app.ts**
        *   **my-integration.ts**
        
    *   Directorysrc/
        
        *   Directorypages/
            
            *   …
            
        *   …
        
    *   astro.config.mjs
    *   package.json
    *   tsconfig.json
    
2.  In `my-integration.ts`, add the following code to provide both the name of your integration and the [`addDevToolbarApp()` function](/en/reference/dev-toolbar-app-reference/#toolbar-app-integration-setup) needed to add your dev toolbar app with the `astro:config:setup` hook:
    
    my-toolbar-app/my-integration.ts
    
        import { fileURLToPath } from 'node:url';import type { AstroIntegration } from 'astro';
        export default {  name: 'my-astro-integration',  hooks: {    'astro:config:setup': ({ addDevToolbarApp }) => {      addDevToolbarApp({        id: "my-toolbar-app",        name: "My Toolbar App",        icon: "🚀",        entrypoint: fileURLToPath(new URL('./app.ts', import.meta.url))      });    },  },} satisfies AstroIntegration;
    
    Using relative paths to the entrypoint
    
    The `entrypoint` is the path to your dev toolbar app file **relative to the root of your existing Astro project**, not to the integration folder (`my-toolbar-app`) itself.
    
    To use relative paths for entrypoints, get the path to the current file using `import.meta.url` and resolve the path to the entrypoint from there.
    
3.  To use this integration in your project, add it to the `integrations` array in your `astro.config.mjs` file.
    
    astro.config.mjs
    
        import { defineConfig } from 'astro/config';import myIntegration from './my-toolbar-app/my-integration.ts';
        export default defineConfig({  integrations: [myIntegration],})
    
4.  If not already running, start the dev server. If your integration has been successfully added to your project, you should see a new “undefined” app in the dev toolbar.
    
    But, you will also see an error message that your dev toolbar app has failed to load. This is because you have not yet built the app itself. You will do that in the next section.
    

See the [Astro Integration API documentation](/en/reference/integrations-reference/) for more about building Astro integrations.

### Creating the app

[Section titled Creating the app](#creating-the-app)

Dev toolbar apps are defined using the `defineToolbarApp()` function from the `astro/toolbar` module. This function takes an object with an `init()` function that will be called when the dev toolbar app is loaded.

This `init()` function contains your app logic to render elements to the screen, send and receive client-side events from the dev toolbar, and communicate with the server.

app.ts

    import { defineToolbarApp } from "astro/toolbar";
    export default defineToolbarApp({    init(canvas, app, server) {      // ...    },});

To display motivational messages on the screen, you will use the `canvas` property to access a standard [ShadowRoot](https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot). Elements can be created and added to the ShadowRoot using the standard DOM APIs.

1.  Copy the following code into `my-toolbar-app/app.ts`. This provides a list of motivational messages, and the logic to create a new `<h1>` element with a random message:
    
    my-toolbar-app/app.ts
    
        import { defineToolbarApp } from "astro/toolbar";
        const motivationalMessages = [  "You're doing great!",  "Keep up the good work!",  "You're awesome!",  "You're a star!",];
        export default defineToolbarApp({    init(canvas) {      const h1 = document.createElement('h1');      h1.textContent = motivationalMessages[Math.floor(Math.random() * motivationalMessages.length)];
              canvas.append(h1);    },});
    
2.  Start the dev server if it is not already running and toggle the app on in the dev toolbar. If your app is working successfully, you will see a motivational message displayed in the top-left corner of the screen. (And, it’s true!)
    
    However, this message will not change when the app is toggled on and off, as the `init()` function is only called once when the app is loaded.
    
3.  To add client-side interactivity to your app, add the `app` argument and use `onAppToggled()` to select a new random message each time your toolbar app is toggled on:
    
    app.ts
    
        import { defineToolbarApp } from "astro/toolbar";
        const motivationalMessages = [  "You're doing great!",  "Keep up the good work!",  "You're awesome!",  "You're a star!",];
        export default defineToolbarApp({    init(canvas, app) {      const h1 = document.createElement('h1');      h1.textContent = motivationalMessages[Math.floor(Math.random() * motivationalMessages.length)];
              canvas.append(h1);
              // Display a random message when the app is toggled      app.onToggled(({ state }) => {        const newMessage = motivationalMessages[Math.floor(Math.random() * motivationalMessages.length)];        h1.textContent = newMessage;      });    },});
    
4.  In your browser preview, toggle your app on and off several times. With this change, a new random message will be selected every time you toggle the app on, providing you with an infinite source of motivation!
    

See the [Astro Dev Toolbar API documentation](/en/reference/dev-toolbar-app-reference/) for more about building dev toolbar apps.

Building apps with a UI framework
---------------------------------

[Section titled Building apps with a UI framework](#building-apps-with-a-ui-framework)

UI frameworks like React, Vue, or Svelte can also be used to create dev toolbar apps. These frameworks provide a more declarative way to create UIs and can make your code more maintainable and easier to read.

The same motivational dev toolbar app built into your existing Astro project earlier on this page with JavaScript can be built using a UI framework (e.g. Preact) instead. Depending on your chosen framework, you may or may not require a build step.

Note

However you choose to build your dev toolbar app, using JavaScript or a UI framework, you will still need to [create the integration](#creating-the-astro-integration) that adds your app to the dev toolbar.

### Without a build step

[Section titled Without a build step](#without-a-build-step)

If your framework supports it, you can create a dev toolbar app without a build step. For example, you can use Preact’s `h` function to create elements and render them directly to the ShadowRoot:

app.ts

    import { defineToolbarApp } from "astro/toolbar";import { render, h } from "preact";
    const motivationalMessages = [  "You're doing great!",  "Keep up the good work!",  "You're awesome!",  "You're a star!",];
    export default defineToolbarApp({    init(canvas) {      const message = motivationalMessages[Math.floor(Math.random() * motivationalMessages.length)];      render(h('h1', null, message), canvas);    },});

Alternatively, the [`htm` package](https://github.com/developit/htm) is a good choice for creating dev toolbar apps without a build step, offering native integration for React and Preact and support for other frameworks:

app.ts

    import { defineToolbarApp } from "astro/toolbar";import { render } from "preact";import { html } from 'htm/preact';
    const motivationalMessages = [  "You're doing great!",  "Keep up the good work!",  "You're awesome!",  "You're a star!",];
    export default defineToolbarApp({    init(canvas) {      const message = motivationalMessages[Math.floor(Math.random() * motivationalMessages.length)];      render(html`<h1>${message}</h1>`, canvas);    },});

In both cases, you can now start your project and see the motivational message displayed in the top-left corner of the screen when you toggle the app on.

### With a build step

[Section titled With a build step](#with-a-build-step)

Astro does not preprocess JSX code in dev toolbar apps, so a build step is required in order to use JSX components in your dev toolbar app.

The following steps will use TypeScript to do this, but any other tools that compile JSX code will also work (e.g. Babel, Rollup, ESBuild).

1.  Install TypeScript inside your project:
    
    *   [npm](#tab-panel-1784)
    *   [pnpm](#tab-panel-1785)
    *   [Yarn](#tab-panel-1786)
    
    Terminal window
    
        npm install --save-dev typescript
    
    Terminal window
    
        pnpm install --save-dev typescript
    
    Terminal window
    
        yarn add --dev typescript
    
2.  Create a `tsconfig.json` file in the root of your toolbar app’s folder with the appropriate settings to build and for the framework you’re using ([React](https://react-typescript-cheatsheet.netlify.app/docs/basic/setup), [Preact](https://preactjs.com/guide/v10/typescript), [Solid](https://www.solidjs.com/guides/typescript)). For example, for Preact:
    
    my-toolbar-app/tsconfig.json
    
        {  "compilerOptions": {    "skipLibCheck": true,    "module": "NodeNext",    "jsx": "react-jsx",    "jsxImportSource": "preact",  }}
    
3.  Adjust the `entrypoint` in your integration to point to the compiled file, remembering that this file is relative to the root of your Astro project:
    
    my-integration.ts
    
        addDevToolbarApp({  id: "my-toolbar-app",  name: "My Toolbar App",  icon: "🚀",  entrypoint: join(__dirname, "./app.js"),});
    
4.  Run `tsc` to build your toolbar app, or `tsc --watch` to automatically rebuild your app when you make changes.
    
    With these changes, you can now rename your `app.ts` file to `app.tsx` (or `.jsx`) and use JSX syntax to create your dev toolbar app:
    
    app.tsx
    
        import { defineToolbarApp } from "astro/toolbar";import { render } from "preact";
        const motivationalMessages = [  "You're doing great!",  "Keep up the good work!",  "You're awesome!",  "You're a star!",];
        export default defineToolbarApp({    init(canvas) {      const message = motivationalMessages[Math.floor(Math.random() * motivationalMessages.length)];      render(<h1>{message}</h1>, canvas);    },});
    

You should now have all the tools you need to create a dev toolbar app using a UI framework of your choice!

Recipes

![](/_astro/CodingInPublic.DpaYu7Qd_5sx41.webp)

Learn Astro with **Coding in Public**
-------------------------------------

150+ video lessons • Astro v5 ready

[Get 20% off](https://learnastro.dev?code=ASTRO_PROMO)

document.querySelectorAll("a\[data-learn-astro-cta\]").forEach(a=>a.addEventListener("click",()=>{window.fathom?.trackEvent("Docs: Coding in Public campaign click")}));

[Edit page](https://github.com/withastro/docs/edit/main/src/content/docs/en/recipes/making-toolbar-apps.mdx) [Translate this page](https://contribute.docs.astro.build/guides/i18n/)

[Previous  
Add i18n features](/en/recipes/i18n/) [Next  
Add last modified time](/en/recipes/modified-time/)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)



# Aggregated from ./pages/recipes/modified-time
Add last modified time
======================

Learn how to build a [remark plugin](https://github.com/remarkjs/remark) that adds the last modified time to the frontmatter of your Markdown and MDX files. Use this property to display the modified time in your pages.

Uses Git history

This recipe calculates time based on your repository’s Git history and may not be accurate on some deployment platforms. Your host may be performing **shallow clones** which do not retrieve the full git history.

Recipe
------

[Section titled Recipe](#recipe)

1.  Install Helper Packages
    
    Install [`Day.js`](https://www.npmjs.com/package/dayjs) to modify and format times:
    
    (() => { class StarlightTabsRestore extends HTMLElement { connectedCallback() { const starlightTabs = this.closest('starlight-tabs'); if (!(starlightTabs instanceof HTMLElement) || typeof localStorage === 'undefined') return; const syncKey = starlightTabs.dataset.syncKey; if (!syncKey) return; const label = localStorage.getItem(\`starlight-synced-tabs\_\_${syncKey}\`); if (!label) return; const tabs = \[...starlightTabs?.querySelectorAll('\[role="tab"\]')\]; const tabIndexToRestore = tabs.findIndex( (tab) => tab instanceof HTMLAnchorElement && tab.textContent?.trim() === label ); const panels = starlightTabs?.querySelectorAll(':scope > \[role="tabpanel"\]'); const newTab = tabs\[tabIndexToRestore\]; const newPanel = panels\[tabIndexToRestore\]; if (tabIndexToRestore < 1 || !newTab || !newPanel) return; tabs\[0\]?.setAttribute('aria-selected', 'false'); tabs\[0\]?.setAttribute('tabindex', '-1'); panels?.\[0\]?.setAttribute('hidden', 'true'); newTab.removeAttribute('tabindex'); newTab.setAttribute('aria-selected', 'true'); newPanel.removeAttribute('hidden'); } } customElements.define('starlight-tabs-restore', StarlightTabsRestore); })()
    
    *   [npm](#tab-panel-1787)
    *   [pnpm](#tab-panel-1788)
    *   [Yarn](#tab-panel-1789)
    
    Terminal window
    
        npm install dayjs
    
    Terminal window
    
        pnpm add dayjs
    
    Terminal window
    
        yarn add dayjs
    
    class r extends HTMLElement{static#e=new Map;#t;#n="starlight-synced-tabs\_\_";constructor(){super();const t=this.querySelector('\[role="tablist"\]');if(this.tabs=\[...t.querySelectorAll('\[role="tab"\]')\],this.panels=\[...this.querySelectorAll(':scope > \[role="tabpanel"\]')\],this.#t=this.dataset.syncKey,this.#t){const i=r.#e.get(this.#t)??\[\];i.push(this),r.#e.set(this.#t,i)}this.tabs.forEach((i,c)=>{i.addEventListener("click",e=>{e.preventDefault();const n=t.querySelector('\[aria-selected="true"\]');e.currentTarget!==n&&this.switchTab(e.currentTarget,c)}),i.addEventListener("keydown",e=>{const n=this.tabs.indexOf(e.currentTarget),s=e.key==="ArrowLeft"?n-1:e.key==="ArrowRight"?n+1:e.key==="Home"?0:e.key==="End"?this.tabs.length-1:null;s!==null&&this.tabs\[s\]&&(e.preventDefault(),this.switchTab(this.tabs\[s\],s))})})}switchTab(t,i,c=!0){if(!t)return;const e=c?this.getBoundingClientRect().top:0;this.tabs.forEach(s=>{s.setAttribute("aria-selected","false"),s.setAttribute("tabindex","-1")}),this.panels.forEach(s=>{s.hidden=!0});const n=this.panels\[i\];n&&(n.hidden=!1),t.removeAttribute("tabindex"),t.setAttribute("aria-selected","true"),c&&(t.focus(),r.#r(this,t),window.scrollTo({top:window.scrollY+(this.getBoundingClientRect().top-e),behavior:"instant"}))}#i(t){!this.#t||typeof localStorage>"u"||localStorage.setItem(this.#n+this.#t,t)}static#r(t,i){const c=t.#t,e=r.#s(i);if(!c||!e)return;const n=r.#e.get(c);if(n){for(const s of n){if(s===t)continue;const a=s.tabs.findIndex(o=>r.#s(o)===e);a!==-1&&s.switchTab(s.tabs\[a\],a,!1)}t.#i(e)}}static#s(t){return t.textContent?.trim()}}customElements.define("starlight-tabs",r);
2.  Create a Remark Plugin
    
    This plugin uses `execSync` to run a Git command that returns the timestamp of the latest commit in ISO 8601 format. The timestamp is then added to the frontmatter of the file.
    
    remark-modified-time.mjs
    
        import { execSync } from "child_process";
        export function remarkModifiedTime() {  return function (tree, file) {    const filepath = file.history[0];    const result = execSync(`git log -1 --pretty="format:%cI" "${filepath}"`);    file.data.astro.frontmatter.lastModified = result.toString();  };}
    
    Using the file system instead of Git
    
    Although using Git is the recommended way to get the last modified timestamp from a file, it is possible to use the file system modified time. This plugin uses `statSync` to get the `mtime` (modified time) of the file in ISO 8601 format. The timestamp is then added to the frontmatter of the file.
    
    remark-modified-time.mjs
    
        import { statSync } from "fs";
        export function remarkModifiedTime() {  return function (tree, file) {    const filepath = file.history[0];    const result = statSync(filepath);    file.data.astro.frontmatter.lastModified = result.mtime.toISOString();  };}
    
3.  Add the plugin to your config
    
    astro.config.mjs
    
        import { defineConfig } from 'astro/config';import { remarkModifiedTime } from './remark-modified-time.mjs';
        export default defineConfig({  markdown: {    remarkPlugins: [remarkModifiedTime],  },});
    
    Now all Markdown documents will have a `lastModified` property in their frontmatter.
    
4.  Display Last Modified Time
    
    If your content is stored in a [content collection](/en/guides/content-collections/), access the `remarkPluginFrontmatter` from the `render(entry)` function. Then render `lastModified` in your template wherever you would like it to appear.
    
    src/pages/posts/\[slug\].astro
    
        ---import { getCollection, render } from 'astro:content';import dayjs from "dayjs";import utc from "dayjs/plugin/utc";
        dayjs.extend(utc);
        export async function getStaticPaths() {  const blog = await getCollection('blog');  return blog.map(entry => ({    params: { slug: entry.id },    props: { entry },  }));}
        const { entry } = Astro.props;const { Content, remarkPluginFrontmatter } = await render(entry);
        const lastModified = dayjs(remarkPluginFrontmatter.lastModified)  .utc()  .format("HH:mm:ss DD MMMM YYYY UTC");---
        <html>  <head>...</head>  <body>    ...    <p>Last Modified: {lastModified}</p>    ...  </body></html>
    
    If you’re using a [Markdown layout](/en/basics/layouts/#markdown-layouts), use the `lastModified` frontmatter property from `Astro.props` in your layout template.
    
    src/layouts/BlogLayout.astro
    
        ---import dayjs from "dayjs";import utc from "dayjs/plugin/utc";
        dayjs.extend(utc);
        const lastModified = dayjs()  .utc(Astro.props.frontmatter.lastModified)  .format("HH:mm:ss DD MMMM YYYY UTC");---
        <html>  <head>...</head>  <body>    <p>{lastModified}</p>    <slot />  </body></html>
    

Recipes

![](/_astro/CodingInPublic.DpaYu7Qd_5sx41.webp)

Learn Astro with **Coding in Public**
-------------------------------------

150+ video lessons • Astro v5 ready

[Get 20% off](https://learnastro.dev?code=ASTRO_PROMO)

document.querySelectorAll("a\[data-learn-astro-cta\]").forEach(a=>a.addEventListener("click",()=>{window.fathom?.trackEvent("Docs: Coding in Public campaign click")}));

[Edit page](https://github.com/withastro/docs/edit/main/src/content/docs/en/recipes/modified-time.mdx) [Translate this page](https://contribute.docs.astro.build/guides/i18n/)

[Previous  
Create a dev toolbar app](/en/recipes/making-toolbar-apps/) [Next  
Add reading time](/en/recipes/reading-time/)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)



# Aggregated from ./pages/recipes/reading-time
Add reading time
================

Create a [remark plugin](https://github.com/remarkjs/remark) which adds a reading time property to the frontmatter of your Markdown or MDX files. Use this property to display the reading time for each page.

Recipe
------

[Section titled Recipe](#recipe)

1.  Install Helper Packages
    
    Install these two helper packages:
    
    *   [`reading-time`](https://www.npmjs.com/package/reading-time) to calculate minutes read
    *   [`mdast-util-to-string`](https://www.npmjs.com/package/mdast-util-to-string) to extract all text from your markdown
    
    (() => { class StarlightTabsRestore extends HTMLElement { connectedCallback() { const starlightTabs = this.closest('starlight-tabs'); if (!(starlightTabs instanceof HTMLElement) || typeof localStorage === 'undefined') return; const syncKey = starlightTabs.dataset.syncKey; if (!syncKey) return; const label = localStorage.getItem(\`starlight-synced-tabs\_\_${syncKey}\`); if (!label) return; const tabs = \[...starlightTabs?.querySelectorAll('\[role="tab"\]')\]; const tabIndexToRestore = tabs.findIndex( (tab) => tab instanceof HTMLAnchorElement && tab.textContent?.trim() === label ); const panels = starlightTabs?.querySelectorAll(':scope > \[role="tabpanel"\]'); const newTab = tabs\[tabIndexToRestore\]; const newPanel = panels\[tabIndexToRestore\]; if (tabIndexToRestore < 1 || !newTab || !newPanel) return; tabs\[0\]?.setAttribute('aria-selected', 'false'); tabs\[0\]?.setAttribute('tabindex', '-1'); panels?.\[0\]?.setAttribute('hidden', 'true'); newTab.removeAttribute('tabindex'); newTab.setAttribute('aria-selected', 'true'); newPanel.removeAttribute('hidden'); } } customElements.define('starlight-tabs-restore', StarlightTabsRestore); })()
    
    *   [npm](#tab-panel-1790)
    *   [pnpm](#tab-panel-1791)
    *   [Yarn](#tab-panel-1792)
    
    Terminal window
    
        npm install reading-time mdast-util-to-string
    
    Terminal window
    
        pnpm add reading-time mdast-util-to-string
    
    Terminal window
    
        yarn add reading-time mdast-util-to-string
    
    class r extends HTMLElement{static#e=new Map;#t;#n="starlight-synced-tabs\_\_";constructor(){super();const t=this.querySelector('\[role="tablist"\]');if(this.tabs=\[...t.querySelectorAll('\[role="tab"\]')\],this.panels=\[...this.querySelectorAll(':scope > \[role="tabpanel"\]')\],this.#t=this.dataset.syncKey,this.#t){const i=r.#e.get(this.#t)??\[\];i.push(this),r.#e.set(this.#t,i)}this.tabs.forEach((i,c)=>{i.addEventListener("click",e=>{e.preventDefault();const n=t.querySelector('\[aria-selected="true"\]');e.currentTarget!==n&&this.switchTab(e.currentTarget,c)}),i.addEventListener("keydown",e=>{const n=this.tabs.indexOf(e.currentTarget),s=e.key==="ArrowLeft"?n-1:e.key==="ArrowRight"?n+1:e.key==="Home"?0:e.key==="End"?this.tabs.length-1:null;s!==null&&this.tabs\[s\]&&(e.preventDefault(),this.switchTab(this.tabs\[s\],s))})})}switchTab(t,i,c=!0){if(!t)return;const e=c?this.getBoundingClientRect().top:0;this.tabs.forEach(s=>{s.setAttribute("aria-selected","false"),s.setAttribute("tabindex","-1")}),this.panels.forEach(s=>{s.hidden=!0});const n=this.panels\[i\];n&&(n.hidden=!1),t.removeAttribute("tabindex"),t.setAttribute("aria-selected","true"),c&&(t.focus(),r.#r(this,t),window.scrollTo({top:window.scrollY+(this.getBoundingClientRect().top-e),behavior:"instant"}))}#i(t){!this.#t||typeof localStorage>"u"||localStorage.setItem(this.#n+this.#t,t)}static#r(t,i){const c=t.#t,e=r.#s(i);if(!c||!e)return;const n=r.#e.get(c);if(n){for(const s of n){if(s===t)continue;const a=s.tabs.findIndex(o=>r.#s(o)===e);a!==-1&&s.switchTab(s.tabs\[a\],a,!1)}t.#i(e)}}static#s(t){return t.textContent?.trim()}}customElements.define("starlight-tabs",r);
2.  Create a remark plugin.
    
    This plugin uses the `mdast-util-to-string` package to get the Markdown file’s text. This text is then passed to the `reading-time` package to calculate the reading time in minutes.
    
    remark-reading-time.mjs
    
        import getReadingTime from 'reading-time';import { toString } from 'mdast-util-to-string';
        export function remarkReadingTime() {  return function (tree, { data }) {    const textOnPage = toString(tree);    const readingTime = getReadingTime(textOnPage);    // readingTime.text will give us minutes read as a friendly string,    // i.e. "3 min read"    data.astro.frontmatter.minutesRead = readingTime.text;  };}
    
3.  Add the plugin to your config:
    
    astro.config.mjs
    
        import { defineConfig } from 'astro/config';import { remarkReadingTime } from './remark-reading-time.mjs';
        export default defineConfig({  markdown: {    remarkPlugins: [remarkReadingTime],  },});
    
    Now all Markdown documents will have a calculated `minutesRead` property in their frontmatter.
    
4.  Display Reading Time
    
    If your blog posts are stored in a [content collection](/en/guides/content-collections/), access the `remarkPluginFrontmatter` from the `render(entry)` function. Then, render `minutesRead` in your template wherever you would like it to appear.
    
    src/pages/posts/\[slug\].astro
    
        ---import { getCollection, render } from 'astro:content';
        export async function getStaticPaths() {  const blog = await getCollection('blog');  return blog.map(entry => ({    params: { slug: entry.id },    props: { entry },  }));}
        const { entry } = Astro.props;const { Content, remarkPluginFrontmatter } = await render(entry);---
        <html>  <head>...</head>  <body>    ...    <p>{remarkPluginFrontmatter.minutesRead}</p>    ...  </body></html>
    
    If you’re using a [Markdown layout](/en/basics/layouts/#markdown-layouts), use the `minutesRead` frontmatter property from `Astro.props` in your layout template.
    
    src/layouts/BlogLayout.astro
    
        ---const { minutesRead } = Astro.props.frontmatter;---
        <html>  <head>...</head>  <body>    <p>{minutesRead}</p>    <slot />  </body></html>
    

Recipes

![](/_astro/CodingInPublic.DpaYu7Qd_5sx41.webp)

Learn Astro with **Coding in Public**
-------------------------------------

150+ video lessons • Astro v5 ready

[Get 20% off](https://learnastro.dev?code=ASTRO_PROMO)

document.querySelectorAll("a\[data-learn-astro-cta\]").forEach(a=>a.addEventListener("click",()=>{window.fathom?.trackEvent("Docs: Coding in Public campaign click")}));

[Edit page](https://github.com/withastro/docs/edit/main/src/content/docs/en/recipes/reading-time.mdx) [Translate this page](https://contribute.docs.astro.build/guides/i18n/)

[Previous  
Add last modified time](/en/recipes/modified-time/) [Next  
Add an RSS feed](/en/recipes/rss/)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)



# Aggregated from ./pages/recipes/rss
Add an RSS feed
===============

Astro supports fast, automatic RSS feed generation for blogs and other content websites. RSS feeds provide an easy way for users to subscribe to your content.

Setting up `@astrojs/rss`
-------------------------

[Section titled Setting up @astrojs/rss](#setting-up-astrojsrss)

The package [`@astrojs/rss`](https://github.com/withastro/astro/tree/main/packages/astro-rss) provides helpers for generating RSS feeds using [API endpoints](/en/guides/endpoints/#static-file-endpoints). This unlocks both static builds _and_ on-demand generation when using an [SSR adapter](/en/guides/on-demand-rendering/).

1.  Install `@astrojs/rss` using your preferred package manager:
    
    (() => { class StarlightTabsRestore extends HTMLElement { connectedCallback() { const starlightTabs = this.closest('starlight-tabs'); if (!(starlightTabs instanceof HTMLElement) || typeof localStorage === 'undefined') return; const syncKey = starlightTabs.dataset.syncKey; if (!syncKey) return; const label = localStorage.getItem(\`starlight-synced-tabs\_\_${syncKey}\`); if (!label) return; const tabs = \[...starlightTabs?.querySelectorAll('\[role="tab"\]')\]; const tabIndexToRestore = tabs.findIndex( (tab) => tab instanceof HTMLAnchorElement && tab.textContent?.trim() === label ); const panels = starlightTabs?.querySelectorAll(':scope > \[role="tabpanel"\]'); const newTab = tabs\[tabIndexToRestore\]; const newPanel = panels\[tabIndexToRestore\]; if (tabIndexToRestore < 1 || !newTab || !newPanel) return; tabs\[0\]?.setAttribute('aria-selected', 'false'); tabs\[0\]?.setAttribute('tabindex', '-1'); panels?.\[0\]?.setAttribute('hidden', 'true'); newTab.removeAttribute('tabindex'); newTab.setAttribute('aria-selected', 'true'); newPanel.removeAttribute('hidden'); } } customElements.define('starlight-tabs-restore', StarlightTabsRestore); })()
    
    *   [npm](#tab-panel-1793)
    *   [pnpm](#tab-panel-1794)
    *   [Yarn](#tab-panel-1795)
    
    Terminal window
    
        npm install @astrojs/rss
    
    Terminal window
    
        pnpm add @astrojs/rss
    
    Terminal window
    
        yarn add @astrojs/rss
    
    class r extends HTMLElement{static#e=new Map;#t;#n="starlight-synced-tabs\_\_";constructor(){super();const t=this.querySelector('\[role="tablist"\]');if(this.tabs=\[...t.querySelectorAll('\[role="tab"\]')\],this.panels=\[...this.querySelectorAll(':scope > \[role="tabpanel"\]')\],this.#t=this.dataset.syncKey,this.#t){const i=r.#e.get(this.#t)??\[\];i.push(this),r.#e.set(this.#t,i)}this.tabs.forEach((i,c)=>{i.addEventListener("click",e=>{e.preventDefault();const n=t.querySelector('\[aria-selected="true"\]');e.currentTarget!==n&&this.switchTab(e.currentTarget,c)}),i.addEventListener("keydown",e=>{const n=this.tabs.indexOf(e.currentTarget),s=e.key==="ArrowLeft"?n-1:e.key==="ArrowRight"?n+1:e.key==="Home"?0:e.key==="End"?this.tabs.length-1:null;s!==null&&this.tabs\[s\]&&(e.preventDefault(),this.switchTab(this.tabs\[s\],s))})})}switchTab(t,i,c=!0){if(!t)return;const e=c?this.getBoundingClientRect().top:0;this.tabs.forEach(s=>{s.setAttribute("aria-selected","false"),s.setAttribute("tabindex","-1")}),this.panels.forEach(s=>{s.hidden=!0});const n=this.panels\[i\];n&&(n.hidden=!1),t.removeAttribute("tabindex"),t.setAttribute("aria-selected","true"),c&&(t.focus(),r.#r(this,t),window.scrollTo({top:window.scrollY+(this.getBoundingClientRect().top-e),behavior:"instant"}))}#i(t){!this.#t||typeof localStorage>"u"||localStorage.setItem(this.#n+this.#t,t)}static#r(t,i){const c=t.#t,e=r.#s(i);if(!c||!e)return;const n=r.#e.get(c);if(n){for(const s of n){if(s===t)continue;const a=s.tabs.findIndex(o=>r.#s(o)===e);a!==-1&&s.switchTab(s.tabs\[a\],a,!1)}t.#i(e)}}static#s(t){return t.textContent?.trim()}}customElements.define("starlight-tabs",r);
    
    Tip
    
    Ensure you’ve [configured a `site`](/en/reference/configuration-reference/#site) in your project’s `astro.config`. This will be used to generate links to your RSS articles.
    
2.  Create a file in `src/pages/` with a name of your choice and the extension `.xml.js` to be used as the output URL for your feed. Some common RSS feed URL names are `feed.xml` or `rss.xml`.
    
    The example file below `src/pages/rss.xml.js` will create an RSS feed at `site/rss.xml`.
    
3.  Import the `rss()` helper from the `@astrojs/rss` package into your `.xml.js` file and export a function that returns it using the following parameters:
    
    src/pages/rss.xml.js
    
        import rss from '@astrojs/rss';
        export function GET(context) {  return rss({    // `<title>` field in output xml    title: 'Buzz’s Blog',    // `<description>` field in output xml    description: 'A humble Astronaut’s guide to the stars',    // Pull in your project "site" from the endpoint context    // https://docs.astro.build/en/reference/api-reference/#site    site: context.site,    // Array of `<item>`s in output xml    // See "Generating items" section for examples using content collections and glob imports    items: [],    // (optional) inject custom xml    customData: `<language>en-us</language>`,  });}
    

See the [`@astrojs/rss` README](https://github.com/withastro/astro/tree/main/packages/astro-rss) for the full configuration reference.

Generating `items`
------------------

[Section titled Generating items](#generating-items)

The `items` field accepts a list of RSS feed objects, which can be generated from content collections entries using `getCollection()` or from your page files using `pagesGlobToRssItems()`.

The RSS feed standard format includes metadata for each published item, including values such as:

*   `title`: The title of the entry. Optional only if a `description` is set. Otherwise, required.
*   `description`: A short excerpt from or describing the entry. Optional only if a `title` is set. Otherwise, required.
*   `link`: A URL to the original source of the entry. (optional)
*   `pubDate`: The date of publication of the entry. (optional)
*   `content`: The full content of your post. (optional)

See the [`items` configuration reference](https://github.com/withastro/astro/tree/main/packages/astro-rss#items) for a complete list of options.

### Using content collections

[Section titled Using content collections](#using-content-collections)

To create an RSS feed of pages managed in [content collections](/en/guides/content-collections/), use the `getCollection()` function to retrieve the data required for your `items` array. You will need to specify the values for each desired property (e.g. `title`, `description`) from the returned data.

src/pages/rss.xml.js

    import rss from '@astrojs/rss';import { getCollection } from 'astro:content';
    export async function GET(context) {  const blog = await getCollection('blog');  return rss({    title: 'Buzz’s Blog',    description: 'A humble Astronaut’s guide to the stars',    site: context.site,    items: blog.map((post) => ({      title: post.data.title,      pubDate: post.data.pubDate,      description: post.data.description,      // Compute RSS link from post `id`      // This example assumes all posts are rendered as `/blog/[id]` routes      link: `/blog/${post.id}/`,    })),  });}

Optional: replace your existing blog collection schema to enforce the expected RSS properties.

To ensure that every blog entry produces a valid RSS feed item, you can optionally import and apply `rssSchema` instead of defining each individual property of your schema.

src/content.config.ts

    import { defineCollection } from 'astro:content';import { rssSchema } from '@astrojs/rss';
    const blog = defineCollection({  schema: rssSchema,});
    export const collections = { blog };

### Using glob imports

[Section titled Using glob imports](#using-glob-imports)

**Added in:** `@astrojs/rss@2.1.0`

To create an RSS feed from documents in `src/pages/`, use the `pagesGlobToRssItems()` helper. This accepts an [`import.meta.glob`](https://vite.dev/guide/features.html#glob-import) result and outputs an array of valid RSS feed items (see [more about writing glob patterns](/en/guides/imports/#glob-patterns) for specifying which pages to include).

Caution

This function assumes, but does not verify, that all necessary feed properties are present in each document’s frontmatter. If you encounter errors, verify each page frontmatter manually.

src/pages/rss.xml.js

    import rss, { pagesGlobToRssItems } from '@astrojs/rss';
    export async function GET(context) {  return rss({    title: 'Buzz’s Blog',    description: 'A humble Astronaut’s guide to the stars',    site: context.site,    items: await pagesGlobToRssItems(      import.meta.glob('./blog/*.{md,mdx}'),    ),  });}

Using an older version?

In versions of `@astrojs/rss` before v2.1.0, pass your glob result straight to `items` without the `pagesGlobToRssItems()` wrapper:

    items: import.meta.glob('./blog/*.{md,mdx}'),

This method is deprecated for all versions of Astro since v2.1.0, and cannot be used on modern projects.

### Including full post content

[Section titled Including full post content](#including-full-post-content)

**Added in:** `astro@1.6.14`

The `content` key contains the full content of the post as HTML. This allows you to make your entire post content available to RSS feed readers.

Tip

A package like [`sanitize-html`](https://www.npmjs.com/package/sanitize-html) will make sure that your content is properly sanitized, escaped, and encoded. In the process, such a package might also remove some harmless elements and attributes, so make sure to verify the output and configure the package according to your needs.

When using content collections, render the post `body` using a standard Markdown parser like [`markdown-it`](https://github.com/markdown-it/markdown-it) and sanitize the result, including any extra tags (e.g. `<img>`) needed to render your content:

src/pages/rss.xml.js

    import rss from '@astrojs/rss';import { getCollection } from 'astro:content';import sanitizeHtml from 'sanitize-html';import MarkdownIt from 'markdown-it';const parser = new MarkdownIt();
    export async function GET(context) {  const blog = await getCollection('blog');  return rss({    title: 'Buzz’s Blog',    description: 'A humble Astronaut’s guide to the stars',    site: context.site,    items: blog.map((post) => ({      link: `/blog/${post.id}/`,      // Note: this will not process components or JSX expressions in MDX files.      content: sanitizeHtml(parser.render(post.body), {        allowedTags: sanitizeHtml.defaults.allowedTags.concat(['img'])      }),      ...post.data,    })),  });}

When using glob imports with Markdown, you may use the `compiledContent()` helper to retrieve the rendered HTML for sanitization. Note: this feature is **not** supported for MDX files.

src/pages/rss.xml.js

    import rss from '@astrojs/rss';import sanitizeHtml from 'sanitize-html';
    export async function GET(context) {  const postImportResult = import.meta.glob('../posts/**/*.md', { eager: true });  const posts = Object.values(postImportResult);  return rss({    title: 'Buzz’s Blog',    description: 'A humble Astronaut’s guide to the stars',    site: context.site,    items: await Promise.all(posts.map(async (post) => ({      link: post.url,      content: sanitizeHtml((await post.compiledContent())),      ...post.frontmatter,    }))),  });}

Removing trailing slashes
-------------------------

[Section titled Removing trailing slashes](#removing-trailing-slashes)

Astro’s RSS feed produces links with a trailing slash by default, no matter what value you have configured for `trailingSlash`. This means that your RSS links may not match your post URLs exactly.

If you have set `trailingSlash: "never"` on your `astro.config.mjs`, set `trailingSlash: false` in the `rss()` helper so that your feed matches your project configuration.

src/pages/rss.xml.js

    import rss from '@astrojs/rss';
    export function GET(context) {  const posts = Object.values(postImportResult);  return rss({    title: 'Buzz’s Blog',    description: 'A humble Astronaut’s guide to the stars',    site: context.site,    trailingSlash: false,    items: posts.map((post) => ({      link: post.url,      ...post.frontmatter,    })),  });}

Adding a stylesheet
-------------------

[Section titled Adding a stylesheet](#adding-a-stylesheet)

Style your RSS feed for a more pleasant user experience when viewing the file in your browser.

Use the `rss` function’s `stylesheet` option to specify an absolute path to your stylesheet.

    rss({  // ex. use your stylesheet from "public/rss/styles.xsl"  stylesheet: '/rss/styles.xsl',  // ...});

Tip

If you’d prefer not to create your own stylesheet, you may use a premade stylesheet such as the [Pretty Feed v3 default stylesheet](https://github.com/genmon/aboutfeeds/blob/main/tools/pretty-feed-v3.xsl). Download the stylesheet from GitHub and save into your project’s `public/` directory.

Enabling RSS feed auto-discovery
--------------------------------

[Section titled Enabling RSS feed auto-discovery](#enabling-rss-feed-auto-discovery)

[RSS autodiscovery](https://www.rssboard.org/rss-autodiscovery) allows browsers and other software to automatically find a site’s RSS feed from the main URL.

To enable, add a `<link>` tag with the following attributes to your site’s `head` element:

    <link    rel="alternate"    type="application/rss+xml"    title="Your Site's Title"    href={new URL("rss.xml", Astro.site)}/>

With this tag, readers of your blog can enter your site’s base URL into their RSS reader to subscribe to your posts without needing the specific URL of your RSS feed.

Next Steps
----------

[Section titled Next Steps](#next-steps)

After visiting your feed in the browser at `your-domain.com/rss.xml` and confirming that you can see data for each of your posts, you can now [promote your feed on your website](https://medium.com/samsung-internet-dev/add-rss-feeds-to-your-website-to-keep-your-core-readers-engaged-3179dca9c91e#:~:text=com/~deno%2Drss-,Advertising%20your%20RSS%20feed,-Now%20you%20have). Adding the standard RSS icon to your site lets your readers know that they can subscribe to your posts in their own feed reader.

Resources
---------

[Section titled Resources](#resources)

*   [RSS Feeds](https://aboutfeeds.com/)

Recipes

![](/_astro/CodingInPublic.DpaYu7Qd_5sx41.webp)

Learn Astro with **Coding in Public**
-------------------------------------

150+ video lessons • Astro v5 ready

[Get 20% off](https://learnastro.dev?code=ASTRO_PROMO)

document.querySelectorAll("a\[data-learn-astro-cta\]").forEach(a=>a.addEventListener("click",()=>{window.fathom?.trackEvent("Docs: Coding in Public campaign click")}));

[Edit page](https://github.com/withastro/docs/edit/main/src/content/docs/en/recipes/rss.mdx) [Translate this page](https://contribute.docs.astro.build/guides/i18n/)

[Previous  
Add reading time](/en/recipes/reading-time/) [Next  
Share state between Astro components](/en/recipes/sharing-state/)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)



# Aggregated from ./pages/recipes/sharing-state-islands
Share state between islands
===========================

When building an Astro website with [islands architecture / partial hydration](/en/concepts/islands/), you may have run into this problem: **I want to share state between my components.**

UI frameworks like React or Vue may encourage [“context” providers](https://react.dev/learn/passing-data-deeply-with-context) for other components to consume. But when [partially hydrating components](/en/guides/framework-components/#hydrating-interactive-components) within Astro or Markdown, you can’t use these context wrappers.

Astro recommends a different solution for shared client-side storage: [**Nano Stores**](https://github.com/nanostores/nanostores).

![](/houston_chef.webp) **Related recipe:** [Share state between Astro components](/en/recipes/sharing-state/)

Why Nano Stores?
----------------

[Section titled Why Nano Stores?](#why-nano-stores)

The [Nano Stores](https://github.com/nanostores/nanostores) library allows you to author stores that any component can interact with. We recommend Nano Stores because:

*   **They’re lightweight.** Nano Stores ship the bare minimum JS you’ll need (less than 1 KB) with zero dependencies.
*   **They’re framework-agnostic.** This means sharing state between frameworks will be seamless! Astro is built on flexibility, so we love solutions that offer a similar developer experience no matter your preference.

Still, there are a number of alternatives you can explore. These include:

*   [Svelte’s built-in stores](https://svelte.dev/tutorial/writable-stores)
*   [Solid signals](https://www.solidjs.com/docs/latest) outside of a component context
*   [Vue’s reactivity API](https://vuejs.org/guide/scaling-up/state-management.html#simple-state-management-with-reactivity-api)
*   [Sending custom browser events](https://developer.mozilla.org/en-US/docs/Web/Events/Creating_and_triggering_events) between components

FAQ

**🙋 Can I use Nano Stores in `.astro` files or other server-side components?**

Nano Stores can be used in `<script>` tags to [share state between `.astro` components](/en/recipes/sharing-state/). However, Using Nano Stores in the frontmatter of server-side components is not recommended because of the following restrictions:

*   Writing to a store from a `.astro` file or [non-hydrated component](/en/guides/framework-components/#hydrating-interactive-components) will _not_ affect the value received by [client-side components](/en/reference/directives-reference/#client-directives).
*   You cannot pass a Nano Store as a “prop” to client-side components.
*   You cannot subscribe to store changes from a `.astro` file, since Astro components do not re-render.

If you understand these restrictions and still find a use case, you can give Nano Stores a try! Just remember that Nano Stores are built for reactivity to changes on the **client** specifically.

**🙋 How do Svelte stores compare to Nano Stores?**

**Nano Stores and [Svelte stores](https://svelte.dev/tutorial/writable-stores) are very similar!** In fact, [nanostores allow you to use the same `$` shortcut](https://github.com/nanostores/nanostores#svelte) for subscriptions that you might use with Svelte stores.

If you want to avoid third-party libraries, [Svelte stores](https://svelte.dev/tutorial/writable-stores) are a great cross-island communication tool on their own. Still, you might prefer Nano Stores if a) you like their add-ons for [“objects”](https://github.com/nanostores/nanostores#maps) and [async state](https://github.com/nanostores/nanostores#lazy-stores), or b) you want to communicate between Svelte and other UI frameworks like Preact or Vue.

**🙋 How do Solid signals compare to Nano Stores?**

If you’ve used Solid for a while, you may have tried moving [signals](https://www.solidjs.com/docs/latest#createsignal) or [stores](https://www.solidjs.com/docs/latest#createstore) outside of your components. This is a great way to share state between Solid islands! Try exporting signals from a shared file:

sharedStore.js

    import { createSignal } from 'solid-js';
    export const sharedCount = createSignal(0);

…and all components importing `sharedCount` will share the same state. Though this works well, you might prefer Nano Stores if a) you like their add-ons for [“objects”](https://github.com/nanostores/nanostores#maps) and [async state](https://github.com/nanostores/nanostores#lazy-stores), or b) you want to communicate between Solid and other UI frameworks like Preact or Vue.

Installing Nano Stores
----------------------

[Section titled Installing Nano Stores](#installing-nano-stores)

To get started, install Nano Stores alongside their helper package for your favorite UI framework:

*   [Preact](#tab-panel-1800)
*   [React](#tab-panel-1801)
*   [Solid](#tab-panel-1802)
*   [Svelte](#tab-panel-1803)
*   [Vue](#tab-panel-1804)

Terminal window

    npm install nanostores @nanostores/preact

Terminal window

    npm install nanostores @nanostores/react

Terminal window

    npm install nanostores @nanostores/solid

Terminal window

    npm install nanostores

Note

No helper package here! Nano Stores can be used like standard Svelte stores.

Terminal window

    npm install nanostores @nanostores/vue

You can jump into the [Nano Stores usage guide](https://github.com/nanostores/nanostores#guide) from here, or follow along with our example below!

Usage example - ecommerce cart flyout
-------------------------------------

[Section titled Usage example - ecommerce cart flyout](#usage-example---ecommerce-cart-flyout)

Let’s say we’re building a simple ecommerce interface with three interactive elements:

*   An “add to cart” submission form
*   A cart flyout to display those added items
*   A cart flyout toggle

_[**Try the completed example**](https://github.com/withastro/astro/tree/main/examples/with-nanostores) on your machine or online via StackBlitz._

Your base Astro file may look like this:

src/pages/index.astro

    ---import CartFlyoutToggle from '../components/CartFlyoutToggle';import CartFlyout from '../components/CartFlyout';import AddToCartForm from '../components/AddToCartForm';---
    <!DOCTYPE html><html lang="en"><head>...</head><body>  <header>    <nav>      <a href="/">Astro storefront</a>      <CartFlyoutToggle client:load />    </nav>  </header>  <main>    <AddToCartForm client:load>    <!-- ... -->    </AddToCartForm>  </main>  <CartFlyout client:load /></body></html>

### Using “atoms”

[Section titled Using “atoms”](#using-atoms)

Let’s start by opening our `CartFlyout` whenever `CartFlyoutToggle` is clicked.

First, create a new JS or TS file to contain our store. We’ll use an [“atom”](https://github.com/nanostores/nanostores#atoms) for this:

src/cartStore.js

    import { atom } from 'nanostores';
    export const isCartOpen = atom(false);

Now, we can import this store into any file that needs to read or write. We’ll start by wiring up our `CartFlyoutToggle`:

*   [Preact](#tab-panel-1805)
*   [React](#tab-panel-1806)
*   [Solid](#tab-panel-1807)
*   [Svelte](#tab-panel-1808)
*   [Vue](#tab-panel-1809)

src/components/CartFlyoutToggle.jsx

    import { useStore } from '@nanostores/preact';import { isCartOpen } from '../cartStore';
    export default function CartButton() {  // read the store value with the `useStore` hook  const $isCartOpen = useStore(isCartOpen);  // write to the imported store using `.set`  return (    <button onClick={() => isCartOpen.set(!$isCartOpen)}>Cart</button>  )}

src/components/CartFlyoutToggle.jsx

    import { useStore } from '@nanostores/react';import { isCartOpen } from '../cartStore';
    export default function CartButton() {  // read the store value with the `useStore` hook  const $isCartOpen = useStore(isCartOpen);  // write to the imported store using `.set`  return (    <button onClick={() => isCartOpen.set(!$isCartOpen)}>Cart</button>  )}

src/components/CartFlyoutToggle.jsx

    import { useStore } from '@nanostores/solid';import { isCartOpen } from '../cartStore';
    export default function CartButton() {  // read the store value with the `useStore` hook  const $isCartOpen = useStore(isCartOpen);  // write to the imported store using `.set`  return (    <button onClick={() => isCartOpen.set(!$isCartOpen())}>Cart</button>  )}

src/components/CartFlyoutToggle.svelte

    <script>  import { isCartOpen } from '../cartStore';</script>
    <!--use "$" to read the store value--><button on:click={() => isCartOpen.set(!$isCartOpen)}>Cart</button>

src/components/CartFlyoutToggle.vue

    <template>  <!--write to the imported store using `.set`-->  <button @click="isCartOpen.set(!$isCartOpen)">Cart</button></template>
    <script setup>  import { isCartOpen } from '../cartStore';  import { useStore } from '@nanostores/vue';
      // read the store value with the `useStore` hook  const $isCartOpen = useStore(isCartOpen);</script>

Then, we can read `isCartOpen` from our `CartFlyout` component:

*   [Preact](#tab-panel-1810)
*   [React](#tab-panel-1811)
*   [Solid](#tab-panel-1812)
*   [Svelte](#tab-panel-1813)
*   [Vue](#tab-panel-1814)

src/components/CartFlyout.jsx

    import { useStore } from '@nanostores/preact';import { isCartOpen } from '../cartStore';
    export default function CartFlyout() {  const $isCartOpen = useStore(isCartOpen);
      return $isCartOpen ? <aside>...</aside> : null;}

src/components/CartFlyout.jsx

    import { useStore } from '@nanostores/react';import { isCartOpen } from '../cartStore';
    export default function CartFlyout() {  const $isCartOpen = useStore(isCartOpen);
      return $isCartOpen ? <aside>...</aside> : null;}

src/components/CartFlyout.jsx

    import { useStore } from '@nanostores/solid';import { isCartOpen } from '../cartStore';
    export default function CartFlyout() {  const $isCartOpen = useStore(isCartOpen);
      return $isCartOpen() ? <aside>...</aside> : null;}

src/components/CartFlyout.svelte

    <script>  import { isCartOpen } from '../cartStore';</script>
    {#if $isCartOpen}<aside>...</aside>{/if}

src/components/CartFlyout.vue

    <template>  <aside v-if="$isCartOpen">...</aside></template>
    <script setup>  import { isCartOpen } from '../cartStore';  import { useStore } from '@nanostores/vue';
      const $isCartOpen = useStore(isCartOpen);</script>

### Using “maps”

[Section titled Using “maps”](#using-maps)

Tip

**[Maps](https://github.com/nanostores/nanostores#maps) are a great choice for objects you write to regularly!** Alongside the standard `get()` and `set()` helpers an `atom` provides, you’ll also have a `.setKey()` function to efficiently update individual object keys.

Now, let’s keep track of the items inside your cart. To avoid duplicates and keep track of “quantity,” we can store your cart as an object with the item’s ID as a key. We’ll use a [Map](https://github.com/nanostores/nanostores#maps) for this.

Let’s add a `cartItem` store to our `cartStore.js` from earlier. You can also switch to a TypeScript file to define the shape if you’re so inclined.

(() => { class StarlightTabsRestore extends HTMLElement { connectedCallback() { const starlightTabs = this.closest('starlight-tabs'); if (!(starlightTabs instanceof HTMLElement) || typeof localStorage === 'undefined') return; const syncKey = starlightTabs.dataset.syncKey; if (!syncKey) return; const label = localStorage.getItem(\`starlight-synced-tabs\_\_${syncKey}\`); if (!label) return; const tabs = \[...starlightTabs?.querySelectorAll('\[role="tab"\]')\]; const tabIndexToRestore = tabs.findIndex( (tab) => tab instanceof HTMLAnchorElement && tab.textContent?.trim() === label ); const panels = starlightTabs?.querySelectorAll(':scope > \[role="tabpanel"\]'); const newTab = tabs\[tabIndexToRestore\]; const newPanel = panels\[tabIndexToRestore\]; if (tabIndexToRestore < 1 || !newTab || !newPanel) return; tabs\[0\]?.setAttribute('aria-selected', 'false'); tabs\[0\]?.setAttribute('tabindex', '-1'); panels?.\[0\]?.setAttribute('hidden', 'true'); newTab.removeAttribute('tabindex'); newTab.setAttribute('aria-selected', 'true'); newPanel.removeAttribute('hidden'); } } customElements.define('starlight-tabs-restore', StarlightTabsRestore); })()

*   [JavaScript](#tab-panel-1796)
*   [TypeScript](#tab-panel-1797)

src/cartStore.js

    import { atom, map } from 'nanostores';
    export const isCartOpen = atom(false);
    /** * @typedef {Object} CartItem * @property {string} id * @property {string} name * @property {string} imageSrc * @property {number} quantity */
    /** @type {import('nanostores').MapStore<Record<string, CartItem>>} */export const cartItems = map({});

src/cartStore.ts

    import { atom, map } from 'nanostores';
    export const isCartOpen = atom(false);
    export type CartItem = {  id: string;  name: string;  imageSrc: string;  quantity: number;}
    export const cartItems = map<Record<string, CartItem>>({});

class r extends HTMLElement{static#e=new Map;#t;#n="starlight-synced-tabs\_\_";constructor(){super();const t=this.querySelector('\[role="tablist"\]');if(this.tabs=\[...t.querySelectorAll('\[role="tab"\]')\],this.panels=\[...this.querySelectorAll(':scope > \[role="tabpanel"\]')\],this.#t=this.dataset.syncKey,this.#t){const i=r.#e.get(this.#t)??\[\];i.push(this),r.#e.set(this.#t,i)}this.tabs.forEach((i,c)=>{i.addEventListener("click",e=>{e.preventDefault();const n=t.querySelector('\[aria-selected="true"\]');e.currentTarget!==n&&this.switchTab(e.currentTarget,c)}),i.addEventListener("keydown",e=>{const n=this.tabs.indexOf(e.currentTarget),s=e.key==="ArrowLeft"?n-1:e.key==="ArrowRight"?n+1:e.key==="Home"?0:e.key==="End"?this.tabs.length-1:null;s!==null&&this.tabs\[s\]&&(e.preventDefault(),this.switchTab(this.tabs\[s\],s))})})}switchTab(t,i,c=!0){if(!t)return;const e=c?this.getBoundingClientRect().top:0;this.tabs.forEach(s=>{s.setAttribute("aria-selected","false"),s.setAttribute("tabindex","-1")}),this.panels.forEach(s=>{s.hidden=!0});const n=this.panels\[i\];n&&(n.hidden=!1),t.removeAttribute("tabindex"),t.setAttribute("aria-selected","true"),c&&(t.focus(),r.#r(this,t),window.scrollTo({top:window.scrollY+(this.getBoundingClientRect().top-e),behavior:"instant"}))}#i(t){!this.#t||typeof localStorage>"u"||localStorage.setItem(this.#n+this.#t,t)}static#r(t,i){const c=t.#t,e=r.#s(i);if(!c||!e)return;const n=r.#e.get(c);if(n){for(const s of n){if(s===t)continue;const a=s.tabs.findIndex(o=>r.#s(o)===e);a!==-1&&s.switchTab(s.tabs\[a\],a,!1)}t.#i(e)}}static#s(t){return t.textContent?.trim()}}customElements.define("starlight-tabs",r);

Now, let’s export an `addCartItem` helper for our components to use.

*   **If that item doesn’t exist in your cart**, add the item with a starting quantity of 1.
*   **If that item _does_ already exist**, bump the quantity by 1.

*   [JavaScript](#tab-panel-1798)
*   [TypeScript](#tab-panel-1799)

src/cartStore.js

    ...export function addCartItem({ id, name, imageSrc }) {  const existingEntry = cartItems.get()[id];  if (existingEntry) {    cartItems.setKey(id, {      ...existingEntry,      quantity: existingEntry.quantity + 1,    })  } else {    cartItems.setKey(      id,      { id, name, imageSrc, quantity: 1 }    );  }}

src/cartStore.ts

    ...type ItemDisplayInfo = Pick<CartItem, 'id' | 'name' | 'imageSrc'>;export function addCartItem({ id, name, imageSrc }: ItemDisplayInfo) {  const existingEntry = cartItems.get()[id];  if (existingEntry) {    cartItems.setKey(id, {      ...existingEntry,      quantity: existingEntry.quantity + 1,    });  } else {    cartItems.setKey(      id,      { id, name, imageSrc, quantity: 1 }    );  }}

Note

**🙋 Why use `.get()` here instead of a `useStore` helper?**

You may have noticed we’re calling `cartItems.get()` here, instead of grabbing that `useStore` helper from our React / Preact / Solid / Vue examples. This is because **useStore is meant to trigger component re-renders.** In other words, `useStore` should be used whenever the store value is being rendered to the UI. Since we’re reading the value when an **event** is triggered (`addToCart` in this case), and we aren’t trying to render that value, we don’t need `useStore` here.

With our store in place, we can call this function inside our `AddToCartForm` whenever that form is submitted. We’ll also open the cart flyout so you can see a full cart summary.

*   [Preact](#tab-panel-1815)
*   [React](#tab-panel-1816)
*   [Solid](#tab-panel-1817)
*   [Svelte](#tab-panel-1818)
*   [Vue](#tab-panel-1819)

src/components/AddToCartForm.jsx

    import { addCartItem, isCartOpen } from '../cartStore';
    export default function AddToCartForm({ children }) {  // we'll hardcode the item info for simplicity!  const hardcodedItemInfo = {    id: 'astronaut-figurine',    name: 'Astronaut Figurine',    imageSrc: '/images/astronaut-figurine.png',  }
      function addToCart(e) {    e.preventDefault();    isCartOpen.set(true);    addCartItem(hardcodedItemInfo);  }
      return (    <form onSubmit={addToCart}>      {children}    </form>  )}

src/components/AddToCartForm.jsx

    import { addCartItem, isCartOpen } from '../cartStore';
    export default function AddToCartForm({ children }) {  // we'll hardcode the item info for simplicity!  const hardcodedItemInfo = {    id: 'astronaut-figurine',    name: 'Astronaut Figurine',    imageSrc: '/images/astronaut-figurine.png',  }
      function addToCart(e) {    e.preventDefault();    isCartOpen.set(true);    addCartItem(hardcodedItemInfo);  }
      return (    <form onSubmit={addToCart}>      {children}    </form>  )}

src/components/AddToCartForm.jsx

    import { addCartItem, isCartOpen } from '../cartStore';
    export default function AddToCartForm({ children }) {  // we'll hardcode the item info for simplicity!  const hardcodedItemInfo = {    id: 'astronaut-figurine',    name: 'Astronaut Figurine',    imageSrc: '/images/astronaut-figurine.png',  }
      function addToCart(e) {    e.preventDefault();    isCartOpen.set(true);    addCartItem(hardcodedItemInfo);  }
      return (    <form onSubmit={addToCart}>      {children}    </form>  )}

src/components/AddToCartForm.svelte

    <form on:submit|preventDefault={addToCart}>  <slot></slot></form>
    <script>  import { addCartItem, isCartOpen } from '../cartStore';
      // we'll hardcode the item info for simplicity!  const hardcodedItemInfo = {    id: 'astronaut-figurine',    name: 'Astronaut Figurine',    imageSrc: '/images/astronaut-figurine.png',  }
      function addToCart() {    isCartOpen.set(true);    addCartItem(hardcodedItemInfo);  }</script>

src/components/AddToCartForm.vue

    <template>  <form @submit="addToCart">    <slot></slot>  </form></template>
    <script setup>  import { addCartItem, isCartOpen } from '../cartStore';
      // we'll hardcode the item info for simplicity!  const hardcodedItemInfo = {    id: 'astronaut-figurine',    name: 'Astronaut Figurine',    imageSrc: '/images/astronaut-figurine.png',  }
      function addToCart(e) {    e.preventDefault();    isCartOpen.set(true);    addCartItem(hardcodedItemInfo);  }</script>

Finally, we’ll render those cart items inside our `CartFlyout`:

*   [Preact](#tab-panel-1820)
*   [React](#tab-panel-1821)
*   [Solid](#tab-panel-1822)
*   [Svelte](#tab-panel-1823)
*   [Vue](#tab-panel-1824)

src/components/CartFlyout.jsx

    import { useStore } from '@nanostores/preact';import { isCartOpen, cartItems } from '../cartStore';
    export default function CartFlyout() {  const $isCartOpen = useStore(isCartOpen);  const $cartItems = useStore(cartItems);
      return $isCartOpen ? (    <aside>      {Object.values($cartItems).length ? (        <ul>          {Object.values($cartItems).map(cartItem => (            <li>              <img src={cartItem.imageSrc} alt={cartItem.name} />              <h3>{cartItem.name}</h3>              <p>Quantity: {cartItem.quantity}</p>            </li>          ))}        </ul>      ) : <p>Your cart is empty!</p>}    </aside>  ) : null;}

src/components/CartFlyout.jsx

    import { useStore } from '@nanostores/react';import { isCartOpen, cartItems } from '../cartStore';
    export default function CartFlyout() {  const $isCartOpen = useStore(isCartOpen);  const $cartItems = useStore(cartItems);
      return $isCartOpen ? (    <aside>      {Object.values($cartItems).length ? (        <ul>          {Object.values($cartItems).map(cartItem => (            <li>              <img src={cartItem.imageSrc} alt={cartItem.name} />              <h3>{cartItem.name}</h3>              <p>Quantity: {cartItem.quantity}</p>            </li>          ))}        </ul>      ) : <p>Your cart is empty!</p>}    </aside>  ) : null;}

src/components/CartFlyout.jsx

    import { useStore } from '@nanostores/solid';import { isCartOpen, cartItems } from '../cartStore';
    export default function CartFlyout() {  const $isCartOpen = useStore(isCartOpen);  const $cartItems = useStore(cartItems);
      return $isCartOpen() ? (    <aside>      {Object.values($cartItems()).length ? (        <ul>          {Object.values($cartItems()).map(cartItem => (            <li>              <img src={cartItem.imageSrc} alt={cartItem.name} />              <h3>{cartItem.name}</h3>              <p>Quantity: {cartItem.quantity}</p>            </li>          ))}        </ul>      ) : <p>Your cart is empty!</p>}    </aside>  ) : null;}

src/components/CartFlyout.svelte

    <script>  import { isCartOpen, cartItems } from '../cartStore';</script>
    {#if $isCartOpen}  {#if Object.values($cartItems).length}    <aside>      {#each Object.values($cartItems) as cartItem}      <li>        <img src={cartItem.imageSrc} alt={cartItem.name} />        <h3>{cartItem.name}</h3>        <p>Quantity: {cartItem.quantity}</p>      </li>      {/each}    </aside>  {:else}    <p>Your cart is empty!</p>  {/if}{/if}

src/components/CartFlyout.vue

    <template>  <aside v-if="$isCartOpen">    <ul v-if="Object.values($cartItems).length">      <li v-for="cartItem in Object.values($cartItems)" v-bind:key="cartItem.name">        <img :src=cartItem.imageSrc :alt=cartItem.name />        <h3>{{cartItem.name}}</h3>        <p>Quantity: {{cartItem.quantity}}</p>      </li>    </ul>    <p v-else>Your cart is empty!</p>  </aside></template>
    <script setup>  import { cartItems, isCartOpen } from '../cartStore';  import { useStore } from '@nanostores/vue';
      const $isCartOpen = useStore(isCartOpen);  const $cartItems = useStore(cartItems);</script>

Now, you should have a fully interactive ecommerce example with the smallest JS bundle in the galaxy 🚀

[**Try the completed example**](https://github.com/withastro/astro/tree/main/examples/with-nanostores) on your machine or online via StackBlitz!

Recipes

![](/_astro/CodingInPublic.DpaYu7Qd_5sx41.webp)

Learn Astro with **Coding in Public**
-------------------------------------

150+ video lessons • Astro v5 ready

[Get 20% off](https://learnastro.dev?code=ASTRO_PROMO)

document.querySelectorAll("a\[data-learn-astro-cta\]").forEach(a=>a.addEventListener("click",()=>{window.fathom?.trackEvent("Docs: Coding in Public campaign click")}));

[Edit page](https://github.com/withastro/docs/edit/main/src/content/docs/en/recipes/sharing-state-islands.mdx) [Translate this page](https://contribute.docs.astro.build/guides/i18n/)

[Previous  
Share state between Astro components](/en/recipes/sharing-state/) [Next  
Using streaming to improve page performance](/en/recipes/streaming-improve-page-performance/)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)



# Aggregated from ./pages/recipes/sharing-state
Share state between Astro components
====================================

Tip

Using framework components? See [how to share state between Islands](/en/recipes/sharing-state-islands/)!

When building an Astro website, you may need to share state across components. Astro recommends the use of [Nano Stores](https://github.com/nanostores/nanostores) for shared client storage.

Recipe
------

[Section titled Recipe](#recipe)

1.  Install Nano Stores:
    
    (() => { class StarlightTabsRestore extends HTMLElement { connectedCallback() { const starlightTabs = this.closest('starlight-tabs'); if (!(starlightTabs instanceof HTMLElement) || typeof localStorage === 'undefined') return; const syncKey = starlightTabs.dataset.syncKey; if (!syncKey) return; const label = localStorage.getItem(\`starlight-synced-tabs\_\_${syncKey}\`); if (!label) return; const tabs = \[...starlightTabs?.querySelectorAll('\[role="tab"\]')\]; const tabIndexToRestore = tabs.findIndex( (tab) => tab instanceof HTMLAnchorElement && tab.textContent?.trim() === label ); const panels = starlightTabs?.querySelectorAll(':scope > \[role="tabpanel"\]'); const newTab = tabs\[tabIndexToRestore\]; const newPanel = panels\[tabIndexToRestore\]; if (tabIndexToRestore < 1 || !newTab || !newPanel) return; tabs\[0\]?.setAttribute('aria-selected', 'false'); tabs\[0\]?.setAttribute('tabindex', '-1'); panels?.\[0\]?.setAttribute('hidden', 'true'); newTab.removeAttribute('tabindex'); newTab.setAttribute('aria-selected', 'true'); newPanel.removeAttribute('hidden'); } } customElements.define('starlight-tabs-restore', StarlightTabsRestore); })()
    
    *   [npm](#tab-panel-1825)
    *   [pnpm](#tab-panel-1826)
    *   [Yarn](#tab-panel-1827)
    
    Terminal window
    
        npm install nanostores
    
    Terminal window
    
        pnpm add nanostores
    
    Terminal window
    
        yarn add nanostores
    
    class r extends HTMLElement{static#e=new Map;#t;#n="starlight-synced-tabs\_\_";constructor(){super();const t=this.querySelector('\[role="tablist"\]');if(this.tabs=\[...t.querySelectorAll('\[role="tab"\]')\],this.panels=\[...this.querySelectorAll(':scope > \[role="tabpanel"\]')\],this.#t=this.dataset.syncKey,this.#t){const i=r.#e.get(this.#t)??\[\];i.push(this),r.#e.set(this.#t,i)}this.tabs.forEach((i,c)=>{i.addEventListener("click",e=>{e.preventDefault();const n=t.querySelector('\[aria-selected="true"\]');e.currentTarget!==n&&this.switchTab(e.currentTarget,c)}),i.addEventListener("keydown",e=>{const n=this.tabs.indexOf(e.currentTarget),s=e.key==="ArrowLeft"?n-1:e.key==="ArrowRight"?n+1:e.key==="Home"?0:e.key==="End"?this.tabs.length-1:null;s!==null&&this.tabs\[s\]&&(e.preventDefault(),this.switchTab(this.tabs\[s\],s))})})}switchTab(t,i,c=!0){if(!t)return;const e=c?this.getBoundingClientRect().top:0;this.tabs.forEach(s=>{s.setAttribute("aria-selected","false"),s.setAttribute("tabindex","-1")}),this.panels.forEach(s=>{s.hidden=!0});const n=this.panels\[i\];n&&(n.hidden=!1),t.removeAttribute("tabindex"),t.setAttribute("aria-selected","true"),c&&(t.focus(),r.#r(this,t),window.scrollTo({top:window.scrollY+(this.getBoundingClientRect().top-e),behavior:"instant"}))}#i(t){!this.#t||typeof localStorage>"u"||localStorage.setItem(this.#n+this.#t,t)}static#r(t,i){const c=t.#t,e=r.#s(i);if(!c||!e)return;const n=r.#e.get(c);if(n){for(const s of n){if(s===t)continue;const a=s.tabs.findIndex(o=>r.#s(o)===e);a!==-1&&s.switchTab(s.tabs\[a\],a,!1)}t.#i(e)}}static#s(t){return t.textContent?.trim()}}customElements.define("starlight-tabs",r);
2.  Create a store. In this example, the store tracks whether a dialog is open or not:
    
    src/store.js
    
        import { atom } from 'nanostores';
        export const isOpen = atom(false);
    
3.  Import and use the store in a `<script>` tag in the components that will share state.
    
    The following `Button` and `Dialog` components each use the shared `isOpen` state to control whether a particular `<div>` is hidden or displayed:
    
    src/components/Button.astro
    
        <button id="openDialog">Open</button>
        <script>  import { isOpen } from '../store.js';
          // Set the store to true when the button is clicked  function openDialog() {    isOpen.set(true);  }
          // Add an event listener to the button  document.getElementById('openDialog').addEventListener('click', openDialog);</script>
    
    src/components/Dialog.astro
    
        <div id="dialog" style="display: none">Hello world!</div>
        <script>  import { isOpen } from '../store.js';
          // Listen to changes in the store, and show/hide the dialog accordingly  isOpen.subscribe(open => {    if (open) {      document.getElementById('dialog').style.display = 'block';    } else {      document.getElementById('dialog').style.display = 'none';    }  })</script>
    

Resources
---------

[Section titled Resources](#resources)

*   [Nano Stores on NPM](https://www.npmjs.com/package/nanostores)
*   [Nano Stores documentation for Vanilla JS](https://github.com/nanostores/nanostores#vanilla-js)

Recipes

![](/_astro/CodingInPublic.DpaYu7Qd_5sx41.webp)

Learn Astro with **Coding in Public**
-------------------------------------

150+ video lessons • Astro v5 ready

[Get 20% off](https://learnastro.dev?code=ASTRO_PROMO)

document.querySelectorAll("a\[data-learn-astro-cta\]").forEach(a=>a.addEventListener("click",()=>{window.fathom?.trackEvent("Docs: Coding in Public campaign click")}));

[Edit page](https://github.com/withastro/docs/edit/main/src/content/docs/en/recipes/sharing-state.mdx) [Translate this page](https://contribute.docs.astro.build/guides/i18n/)

[Previous  
Add an RSS feed](/en/recipes/rss/) [Next  
Share state between islands](/en/recipes/sharing-state-islands/)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)



# Aggregated from ./pages/recipes/streaming-improve-page-performance
Using streaming to improve page performance
===========================================

Astro’s SSR uses HTML streaming to send each component to the browser when available for faster page loading. To improve your page’s performance even further, you can build your components strategically to optimize their loading by avoiding blocking data fetches.

The following refactoring example demonstrates how to improve page performance by moving fetch calls to other components, moving them out of a component where they block page rendering.

The following page `await`s some data in its frontmatter. Astro will wait for all of the `fetch` calls to resolve before sending any HTML to the browser.

src/pages/index.astro

    ---const personResponse = await fetch('https://randomuser.me/api/');const personData = await personResponse.json();const randomPerson = personData.results[0];const factResponse = await fetch('https://catfact.ninja/fact');const factData = await factResponse.json();---<html>  <head>    <title>A name and a fact</title>  </head>  <body>    <h2>A name</h2>    <p>{randomPerson.name.first}</p>    <h2>A fact</h2>    <p>{factData.fact}</p>  </body></html>

Moving the `await` calls into smaller components allows you to take advantage of Astro’s streaming. Using the following components to perform the data fetches, Astro can render some HTML first, such as the title, and then the paragraphs when the data is ready.

src/components/RandomName.astro

    ---const personResponse = await fetch('https://randomuser.me/api/');const personData = await personResponse.json();const randomPerson = personData.results[0];---<p>{randomPerson.name.first}</p>

src/components/RandomFact.astro

    ---const factResponse = await fetch('https://catfact.ninja/fact');const factData = await factResponse.json();---<p>{factData.fact}</p>

The Astro page below using these components can render parts of the page sooner. The `<head>`, `<body>`, and `<h2>` tags are no longer blocked by data fetches. The server will then fetch data for `RandomName` and `RandomFact` in parallel and stream the resulting HTML to the browser.

src/pages/index.astro

    ---import RandomName from '../components/RandomName.astro';import RandomFact from '../components/RandomFact.astro';---<html>  <head>    <title>A name and a fact</title>  </head>  <body>    <h2>A name</h2>    <RandomName />    <h2>A fact</h2>    <RandomFact />  </body></html>

#### Including Promises directly

[Section titled Including Promises directly](#including-promises-directly)

You can also include promises directly in the template. Instead of blocking the entire component, it will resolve the promise in parallel and only block the markup that comes after it.

src/pages/index.astro

    ---const personPromise = fetch('https://randomuser.me/api/')  .then(response => response.json())  .then(personData => personData.results[0].name.first);const factPromise = fetch('https://catfact.ninja/fact')  .then(response => response.json())  .then(factData => factData.fact);---<html>  <head>    <title>A name and a fact</title>  </head>  <body>    <h2>A name</h2>    <p>{personPromise}</p>    <h2>A fact</h2>    <p>{factPromise}</p>  </body></html>

In this example, `A name` will render while `personPromise` and `factPromise` are loading. Once `personPromise` has resolved, `A fact` will appear and `factPromise` will render when it’s finished loading.

Recipes

![](/_astro/CodingInPublic.DpaYu7Qd_5sx41.webp)

Learn Astro with **Coding in Public**
-------------------------------------

150+ video lessons • Astro v5 ready

[Get 20% off](https://learnastro.dev?code=ASTRO_PROMO)

document.querySelectorAll("a\[data-learn-astro-cta\]").forEach(a=>a.addEventListener("click",()=>{window.fathom?.trackEvent("Docs: Coding in Public campaign click")}));

[Edit page](https://github.com/withastro/docs/edit/main/src/content/docs/en/recipes/streaming-improve-page-performance.mdx) [Translate this page](https://contribute.docs.astro.build/guides/i18n/)

[Previous  
Share state between islands](/en/recipes/sharing-state-islands/) [Next  
Style rendered Markdown with Tailwind Typography](/en/recipes/tailwind-rendered-markdown/)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)



# Aggregated from ./pages/recipes/tailwind-rendered-markdown
Style rendered Markdown with Tailwind Typography
================================================

You can use [Tailwind](https://tailwindcss.com)’s Typography plugin to style rendered Markdown from sources such as Astro’s [**content collections**](/en/guides/content-collections/).

This recipe will teach you how to create a reusable Astro component to style your Markdown content using Tailwind’s utility classes.

Prerequisites
-------------

[Section titled Prerequisites](#prerequisites)

An Astro project that:

*   has [Tailwind’s Vite plugin](/en/guides/styling/#tailwind) installed.
*   uses Astro’s [content collections](/en/guides/content-collections/).

Setting Up `@tailwindcss/typography`
------------------------------------

[Section titled Setting Up @tailwindcss/typography](#setting-up-tailwindcsstypography)

First, install `@tailwindcss/typography` using your preferred package manager.

(() => { class StarlightTabsRestore extends HTMLElement { connectedCallback() { const starlightTabs = this.closest('starlight-tabs'); if (!(starlightTabs instanceof HTMLElement) || typeof localStorage === 'undefined') return; const syncKey = starlightTabs.dataset.syncKey; if (!syncKey) return; const label = localStorage.getItem(\`starlight-synced-tabs\_\_${syncKey}\`); if (!label) return; const tabs = \[...starlightTabs?.querySelectorAll('\[role="tab"\]')\]; const tabIndexToRestore = tabs.findIndex( (tab) => tab instanceof HTMLAnchorElement && tab.textContent?.trim() === label ); const panels = starlightTabs?.querySelectorAll(':scope > \[role="tabpanel"\]'); const newTab = tabs\[tabIndexToRestore\]; const newPanel = panels\[tabIndexToRestore\]; if (tabIndexToRestore < 1 || !newTab || !newPanel) return; tabs\[0\]?.setAttribute('aria-selected', 'false'); tabs\[0\]?.setAttribute('tabindex', '-1'); panels?.\[0\]?.setAttribute('hidden', 'true'); newTab.removeAttribute('tabindex'); newTab.setAttribute('aria-selected', 'true'); newPanel.removeAttribute('hidden'); } } customElements.define('starlight-tabs-restore', StarlightTabsRestore); })()

*   [npm](#tab-panel-1828)
*   [pnpm](#tab-panel-1829)
*   [Yarn](#tab-panel-1830)

Terminal window

    npm install -D @tailwindcss/typography

Terminal window

    pnpm add -D @tailwindcss/typography

Terminal window

    yarn add --dev @tailwindcss/typography

class r extends HTMLElement{static#e=new Map;#t;#n="starlight-synced-tabs\_\_";constructor(){super();const t=this.querySelector('\[role="tablist"\]');if(this.tabs=\[...t.querySelectorAll('\[role="tab"\]')\],this.panels=\[...this.querySelectorAll(':scope > \[role="tabpanel"\]')\],this.#t=this.dataset.syncKey,this.#t){const i=r.#e.get(this.#t)??\[\];i.push(this),r.#e.set(this.#t,i)}this.tabs.forEach((i,c)=>{i.addEventListener("click",e=>{e.preventDefault();const n=t.querySelector('\[aria-selected="true"\]');e.currentTarget!==n&&this.switchTab(e.currentTarget,c)}),i.addEventListener("keydown",e=>{const n=this.tabs.indexOf(e.currentTarget),s=e.key==="ArrowLeft"?n-1:e.key==="ArrowRight"?n+1:e.key==="Home"?0:e.key==="End"?this.tabs.length-1:null;s!==null&&this.tabs\[s\]&&(e.preventDefault(),this.switchTab(this.tabs\[s\],s))})})}switchTab(t,i,c=!0){if(!t)return;const e=c?this.getBoundingClientRect().top:0;this.tabs.forEach(s=>{s.setAttribute("aria-selected","false"),s.setAttribute("tabindex","-1")}),this.panels.forEach(s=>{s.hidden=!0});const n=this.panels\[i\];n&&(n.hidden=!1),t.removeAttribute("tabindex"),t.setAttribute("aria-selected","true"),c&&(t.focus(),r.#r(this,t),window.scrollTo({top:window.scrollY+(this.getBoundingClientRect().top-e),behavior:"instant"}))}#i(t){!this.#t||typeof localStorage>"u"||localStorage.setItem(this.#n+this.#t,t)}static#r(t,i){const c=t.#t,e=r.#s(i);if(!c||!e)return;const n=r.#e.get(c);if(n){for(const s of n){if(s===t)continue;const a=s.tabs.findIndex(o=>r.#s(o)===e);a!==-1&&s.switchTab(s.tabs\[a\],a,!1)}t.#i(e)}}static#s(t){return t.textContent?.trim()}}customElements.define("starlight-tabs",r);

Then, add the package as a plugin in your Tailwind configuration file.

src/styles/global.css

    @import 'tailwindcss';@plugin '@tailwindcss/typography';

Recipe
------

[Section titled Recipe](#recipe)

1.  Create a `<Prose />` component to provide a wrapping `<div>` with a `<slot />` for your rendered Markdown. Add the style class `prose` alongside any desired [Tailwind element modifiers](https://tailwindcss.com/docs/typography-plugin#element-modifiers) in the parent element.
    
    src/components/Prose.astro
    
        ------<div  class="prose dark:prose-invert  prose-h1:font-bold prose-h1:text-xl  prose-a:text-blue-600 prose-p:text-justify prose-img:rounded-xl  prose-headings:underline">  <slot /></div>
    
    Tip
    
    The `@tailwindcss/typography` plugin uses [**element modifiers**](https://tailwindcss.com/docs/typography-plugin#element-modifiers) to style child components of a container with the `prose` class.
    
    These modifiers follow the following general syntax:
    
        prose-[element]:class-to-apply
    
    For example, `prose-h1:font-bold` gives all `<h1>` tags the `font-bold` Tailwind class.
    
2.  Query your collection entry on the page you want to render your Markdown. Pass the `<Content />` component from `await render(entry)` to `<Prose />` as a child to wrap your Markdown content in Tailwind styles.
    
    src/pages/index.astro
    
        ---import Prose from '../components/Prose.astro';import Layout from '../layouts/Layout.astro';import { getEntry, render } from 'astro:content';
        const entry = await getEntry('collection', 'entry');const { Content } = await render(entry);---<Layout>  <Prose>    <Content />  </Prose></Layout>
    

Resources
---------

[Section titled Resources](#resources)

*   [Tailwind Typography Documentation](https://tailwindcss.com/docs/typography-plugin)

Recipes

![](/_astro/CodingInPublic.DpaYu7Qd_5sx41.webp)

Learn Astro with **Coding in Public**
-------------------------------------

150+ video lessons • Astro v5 ready

[Get 20% off](https://learnastro.dev?code=ASTRO_PROMO)

document.querySelectorAll("a\[data-learn-astro-cta\]").forEach(a=>a.addEventListener("click",()=>{window.fathom?.trackEvent("Docs: Coding in Public campaign click")}));

[Edit page](https://github.com/withastro/docs/edit/main/src/content/docs/en/recipes/tailwind-rendered-markdown.mdx) [Translate this page](https://contribute.docs.astro.build/guides/i18n/)

[Previous  
Using streaming to improve page performance](/en/recipes/streaming-improve-page-performance/) [Next  
Contribute to Astro](/en/contribute/)

[Contribute](/en/contribute/) [Community](https://astro.build/chat) [Sponsor](https://opencollective.com/astrodotbuild)



