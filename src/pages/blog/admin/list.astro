---
// src/pages/blog/admin/list.astro
import { getCollection } from "astro:content";
import AdminLayout from "../../../layouts/AdminLayout.astro";
import { formatDate } from "../../../utils/formatDate";
import type { R2Bucket } from "@cloudflare/workers-types";

const pageTitle = "Manage Blog Posts";
let allPosts = await getCollection("blog");
allPosts.sort((a, b) => b.data.date.valueOf() - a.data.date.valueOf());

// --- Server-Side Data Fetching & State Management ---
const r2Bucket = Astro.locals.runtime?.env?.BLGC_AI_LOGS_BUCKET as R2Bucket | undefined;
// NEW: Use a map for the index data
const postStatusMap = new Map<string, { status: string; [key: string]: any }>();

if (r2Bucket) {
  const indexKey = "qa-datasets/_index.json";
  const indexObject = await r2Bucket.get(indexKey);
  if (indexObject) {
    try {
      const indexData = await indexObject.json<Record<string, any>>();
      for (const slug in indexData) {
        postStatusMap.set(slug, indexData[slug]);
      }
    } catch (e) {
      console.error("Failed to parse QA dataset index file:", e);
    }
  }
}

const generationStartedSlug = Astro.url.searchParams.get('generation_started_for');
const generationLockedSlug = Astro.url.searchParams.get('generation_locked_for');
---

<AdminLayout title={pageTitle}>
  <main class="admin-main">
    <h1>{pageTitle}</h1>
    <p>
      Generate a Q&A dataset for a post. The results will appear here automatically after generation is complete.
    </p>

    {generationStartedSlug && (
      <div class="notification info" id="notification-generating" data-slug={generationStartedSlug}>
        Generation started for post: <strong>{generationStartedSlug}</strong>. This page will update automatically when it's done.
      </div>
    )}

    {generationLockedSlug && (
        <div class="notification warning">
            Generation for <strong>{generationLockedSlug}</strong> is already in progress. Please wait for it to complete.
        </div>
    )}

    <ul class="post-list">
      {
        allPosts.map((post) => {
          const statusInfo = postStatusMap.get(post.slug);
          const status = statusInfo?.status; // 'generating', 'success', 'error', or undefined ('idle')
          
          let statusText = "Idle";
          let statusClass = "status-idle";
          if (status === 'generating') {
            statusText = "Generating..."; // Placeholder, will be updated by script
            statusClass = "status-generating";
          } else if (status === 'success') {
            statusText = `Success (${new Date(statusInfo.generatedAt).toLocaleString()})`;
            statusClass = "status-success";
          } else if (status === 'error') {
            statusText = `Error (${new Date(statusInfo.timestamp).toLocaleString()})`;
            statusClass = "status-error";
          }

          return (
            <li class="post-item" id={`post-item-${post.slug}`}>
              <div class="post-header">
                <div class="post-info">
                  <a href={`/blog/${post.slug}/`} target="_blank">
                    {post.data.title}
                  </a>
                  <span class="post-date">
                    - Published on {formatDate(post.data.date)}
                  </span>
                </div>
                <div class="post-actions">
                  <form action="/api/admin/generate-qa-dataset" method="post" class="generate-form">
                    <input type="hidden" name="slug" value={post.slug} />
                    <button type="submit" class="generate-dataset-btn" disabled={status === 'generating'}>
                      {status === 'success' || status === 'error' ? "Regenerate" : "Generate"}
                    </button>
                  </form>
                  <span 
                    class={`status-indicator ${statusClass}`} 
                    data-status={status} 
                    data-started-at={status === 'generating' ? statusInfo.startedAt : ''}
                  >
                    {statusText}
                  </span>
                  {status === 'generating' && (
                    <button type="button" class="forget-job-btn" data-slug={post.slug}>Forget</button>
                  )}
                </div>
              </div>

              {status === 'error' && (
                <div class="qa-output-container error-container">
                  <h4>Last Generation Failed:</h4>
                  <p class="error-text">{statusInfo.error || 'An unknown error occurred.'}</p>
                </div>
              )}

              {/* The success data is no longer fetched here to speed up page load.
                  The page reloads upon completion to show the updated status. */}
            </li>
          )
        })
      }
    </ul>
  </main>
</AdminLayout>

<script>
  // This script provides progressive enhancement for live status updates.
  document.addEventListener('DOMContentLoaded', () => {
    // --- Disable button on submit to prevent double-clicks ---
    const forms = document.querySelectorAll('.generate-form');
    forms.forEach(form => {
      form.addEventListener('submit', (event) => {
        const button = (event.currentTarget as HTMLFormElement).querySelector('button[type="submit"]');
        if (button) {
          button.disabled = true;
          button.textContent = 'Starting...';
          const slug = (form.querySelector('input[name="slug"]') as HTMLInputElement).value;
          const statusIndicator = document.querySelector(`#post-item-${slug} .status-indicator`);
          if (statusIndicator) {
            statusIndicator.textContent = 'Generating...';
            statusIndicator.className = 'status-indicator status-generating';
          }
        }
      });
    });

    // --- Polling for status updates ---
    const notification = document.getElementById('notification-generating');
    if (notification) {
      const slug = notification.dataset.slug;
      if (slug) {
        let pollCount = 0;
        const maxPolls = 60; // Poll for 5 minutes (60 * 5s)
        const pollInterval = 5000; // 5 seconds

        const poll = setInterval(async () => {
          pollCount++;
          if (pollCount > maxPolls) {
            clearInterval(poll);
            console.error(`Polling for ${slug} timed out.`);
            // Reload to show the latest state from the index, even if it's still 'generating'
            window.location.href = '/blog/admin/list';
            return;
          }

          try {
            const response = await fetch(`/api/admin/qa-dataset-status?slug=${slug}`);
            if (!response.ok) {
              // Stop polling on server error
              clearInterval(poll);
              return;
            }
            const data = await response.json();

            if (data.status === 'success' || data.status === 'error') {
              clearInterval(poll);
              // Reload the page to show the final result from the updated index
              window.location.href = '/blog/admin/list';
            }
            // If status is 'generating' or 'idle' (after lock is gone but before success/error file), keep polling.
          } catch (error) {
            console.error('Polling error:', error);
            clearInterval(poll);
          }
        }, pollInterval);
      }
    }

    // --- NEW: Timer and Forget Job Logic ---
    document.querySelectorAll('.status-indicator[data-status="generating"]').forEach(indicator => {
      const startedAt = (indicator as HTMLElement).dataset.startedAt;
      if (!startedAt) return;

      const startTime = new Date(startedAt).getTime();

      const updateTimer = () => {
        const now = Date.now();
        const elapsedSeconds = Math.round((now - startTime) / 1000);
        const minutes = Math.floor(elapsedSeconds / 60);
        const seconds = elapsedSeconds % 60;
        indicator.textContent = `Generating... (${minutes}m ${seconds}s)`;
      };

      // Update immediately and then every second
      updateTimer();
      const timerId = setInterval(updateTimer, 1000);
      
      // Clean up interval when element is removed (e.g., on page navigation)
      // This is a simple approach; a more robust solution might use MutationObserver
      // but for this admin page, it's likely sufficient.
      indicator.addEventListener('DOMNodeRemoved', () => clearInterval(timerId));
    });

    document.querySelectorAll('.forget-job-btn').forEach(button => {
      button.addEventListener('click', async (event) => {
        const targetButton = event.currentTarget as HTMLButtonElement;
        const slug = targetButton.dataset.slug;

        if (!slug || !confirm(`Are you sure you want to forget the generation job for "${slug}"? This will cancel the current status and allow you to start a new one.`)) {
          return;
        }

        targetButton.disabled = true;
        targetButton.textContent = 'Forgetting...';

        try {
          const response = await fetch('/api/admin/forget-qa-job', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ slug }),
          });

          if (response.ok) {
            // Reload the page to reflect the new state. This is the simplest way.
            window.location.reload();
          } else {
            const errorData = await response.json();
            alert(`Failed to forget job: ${errorData.error || 'Unknown error'}`);
            targetButton.disabled = false;
            targetButton.textContent = 'Forget';
          }
        } catch (error) {
          console.error('Error forgetting job:', error);
          alert('An error occurred while trying to forget the job.');
          targetButton.disabled = false;
          targetButton.textContent = 'Forget';
        }
      });
    });
  });
</script>

<style>
  .admin-main {
    max-width: 900px;
    margin: 2rem auto;
    padding: 2rem;
    background-color: #fff;
    border-radius: 8px;
  }
  .admin-main h1 {
    font-family: var(--font-heading);
    margin-top: 0;
  }
  .notification {
    padding: 1rem;
    border-radius: 4px;
    margin-bottom: 1.5rem;
  }
  .notification.info {
    background-color: #e6f7ff;
    border: 1px solid #91d5ff;
    color: #0050b3;
  }
  .notification.warning {
    background-color: #fffbe6;
    border: 1px solid #ffe58f;
    color: #ad8b00;
  }
  .post-list {
    list-style: none;
    padding: 0;
  }
  .post-item {
    padding: 1.25rem 0;
    border-bottom: 1px solid #eee;
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
  }
  .post-item:last-child {
    border-bottom: none;
  }
  .post-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 1rem;
  }
  .post-info {
    flex-grow: 1;
  }
  .post-info a {
    font-weight: bold;
    font-size: 1.1em;
  }
  .post-date {
    font-size: 0.9em;
    color: #555;
    white-space: nowrap;
  }
  .post-actions {
    display: flex;
    align-items: center;
    gap: 1rem;
    flex-shrink: 0;
  }
  .generate-dataset-btn, .forget-job-btn {
    background-color: var(--cstm-main-surface-secondary);
    color: var(--cstm-text-primary);
    border: 1px solid var(--cstm-text-secondary);
    padding: 0.4em 0.8em;
    border-radius: 4px;
    cursor: pointer;
    font-weight: bold;
    transition: background-color 0.2s ease;
  }
  .generate-dataset-btn:hover:not(:disabled), .forget-job-btn:hover:not(:disabled) {
    background-color: #dcd0c4;
  }
  .generate-dataset-btn:disabled, .forget-job-btn:disabled {
    background-color: #f0f0f0;
    color: #aaa;
    cursor: not-allowed;
  }
  .forget-job-btn {
    background-color: #fee2e2;
    border-color: #fecaca;
    color: #991b1b;
  }
  .forget-job-btn:hover:not(:disabled) {
    background-color: #fecaca;
  }
  .status-indicator {
    font-size: 0.9em;
    padding: 0.2em 0.6em;
    border-radius: 12px;
    font-weight: 500;
    min-width: 100px;
    text-align: center;
  }
  .status-idle {
    color: #555;
    background-color: #f0f0f0;
  }
  .status-generating {
    color: #0050b3;
    background-color: #e6f7ff;
  }
  .status-success {
    color: #1e6641;
    background-color: #dff7e9;
  }
  .status-error {
    color: #991b1b;
    background-color: #fee2e2;
  }
  .qa-output-container {
    margin-top: 0.5rem;
    padding: 0.75rem;
    background-color: #f9f9f9;
    border: 1px solid #eee;
    border-radius: 4px;
    font-size: 0.9em;
  }
  .qa-output-container.error-container {
    background-color: #fff5f5;
    border-color: #fecaca;
  }
  .qa-output-container h4 {
    margin-top: 0;
    margin-bottom: 0.5rem;
  }
  .error-text {
    color: #991b1b;
    font-weight: bold;
    margin: 0;
    white-space: pre-wrap;
    word-break: break-all;
  }
</style>
